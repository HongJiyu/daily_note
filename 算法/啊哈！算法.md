# 排序

通常认为每秒钟允许10亿次

（简陋）桶排序

m为要排序的数的数量。n为m中最大的那个数的值。

时间复杂度：O（2n+2m）=O（n+m）

空间复杂度：O（m中的最大）

缺点：空间占用大。

优点：最快。



冒泡排序

n为要排序的数的数量。

时间复杂度：O（n^2）

空间复杂度：O（n）

缺点：时间复杂度基本不变。除非小优化（一次遍历，不需要调整顺序，则后续可以停止）。



快速排序（最常用的排序）

平均时间复杂度：O（nlogn）算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。如果采用二分法,那么就会以2为底数,三分法就会以3为底数,其他亦然。

解题思想：每一趟取最左边的点为基准。然后通过交换，找到这个基准点的位置（左边小于它，右边大于它）。接下来都同上。

计算：确定第一个数，要比较n-1次，确定第二个数（最优的情况），只要比较n/2次。。。。

```json
function sort(low,high,arr){
    if(low>=high){return};
    const head=low;
    const tail=high;
    const tmp=arr[low];
    while(low<high){
        while(low<high&&arr[high]>tmp){
            high--;
        }
        if(low<high){
            change(arr,low,high);
            low++;
        }
        while(low<high&&arr[low]<tmp){
            low++;
        }
        if(low<high){
            change(arr,low,high);
            high--;
        }
    }
    sort(head,low-1,arr);
    sort(low+1,tail,arr);
}

function change(arr,one,two){
    const tmp=arr[one];
    arr[one]=arr[two];
    arr[two]=tmp;
}

function kp(){
    const arr=[];
    for(let i=0;i<10;i++){
        arr.push(Math.floor(Math.random()*100));
    }
    high=arr.length-1;
    sort(0,high,arr);
    console.log(arr);
}

kp();
```

# 数据结构

队列、栈、链表

# 枚举

奥数

炸弹人

火材棍等式

数的全排列

# 深度搜索

全排列：

```js
function getAllList(num){
    const arr=[],result=[];
    for(let i=1;i<=num;i++ ){
        arr[i]=0;
    }
    ds(arr,"",result);
    console.log(result);
}

function ds(arr,str,result){
    if(str.length===arr.length-1){
        result.push(str);
        return;
    }
    for(let i=1;i<arr.length;i++){
        if(!arr[i]){
            str+=i;
            arr[i]=1;
            ds(arr,str,result);
            str=str.substring(0,str.length-1);
            arr[i]=0;
        }
    }
}
getAllList(5);
```

地图从某点到指定点最短距离

```js
// ---------------迷宫(深度)
let minStep=Number.MAX_VALUE;
function getMinDistance(){
    //地图，1可走，0不可走，2终点
const map=[
    [1,1,0,1],
    [1,1,1,1],
    [1,1,0,1],
    [1,0,2,1],
    [1,1,1,0],
]
// 记录走过的点，同一路线不可再走
const cloneMap=JSON.parse(JSON.stringify(map));
//终点要标记为1，使其能被走
cloneMap[3][2]=1;
ds(map,cloneMap,0,0,0);
console.log(minStep);

}
function ds(map,cloneMap,step,x,y){
    if(map[x][y]===2){minStep=step<minStep?step:minStep;return;}
    if(x+1<cloneMap.length &&cloneMap[x+1][y]===1){
        cloneMap[x+1][y]=0;
        ds(map,cloneMap,step+1,x+1,y);
        cloneMap[x+1][y]=1;
    }
    if(x-1>=0&&cloneMap[x-1][y]===1){
        cloneMap[x-1][y]=0;
        ds(map,cloneMap,step+1,x-1,y);
        cloneMap[x-1][y]=1;
    }
    if(y+1<cloneMap[0].length&&cloneMap[x][y+1]===1){
        cloneMap[x][y+1]=0;
        ds(map,cloneMap,step+1,x,y+1);
        cloneMap[x][y+1]=1;
    }
    if(y-1>=0&&cloneMap[x][y-1]===1){
        cloneMap[x][y-1]=0;
        ds(map,cloneMap,step+1,x,y-1);
        cloneMap[x][y-1]=1;
    }
}
getMinDistance();
```

# 广度搜索

地图从某点到指定点最短距离