通过`object encoding xxx` ，查看该键对应的值是什么编码类型

通过`type xx`，返回该键对应的值是什么对象类型

# 简单动态字符串

使用SDS（simple dynamic string）来保存字符串，而不用c原生的以空字符结尾的字符数组作为字符串实现。

![image-20220212115332146](images\image-20220212115332146.png)

len+free+1 就是这个buf[]占用的字节数。这个1是空字符'\0'

- len轻松获取字符串的长度，O（n）
- 封装了自动扩容，不需要自行判断。防止溢出问题
- 解除了字符串长度和底层数组长度关联，进行增加时预分配，由free记录空余的，缩短时使用惰性删除，即不立即缩小数组，而是用free记录。
- 二进制安全：在C语言中的字符串必须以'\0'结尾而且字符串里面不能包含空字符，这样使得c字符串只能保存文本，不能保存图片、视频、压缩文件这样的二进制数据。如果存储图片的二进制，肯定会有结束符 `\0`，此时，图片就不完整，因而，会出现编码的问题。而sds有len，根据len来读取内容，所以是二进制安全

# 链表

当一个列表键包含数量较多的元素，或者列表元素都是较长的字符串，就会使用链表作为列表键的底层实现。

**由链表头和链表节点组成**

## 链表头

![image-20220212135311659](images\image-20220212135311659.png)

## 链表节点

![image-20220212135235223](images\image-20220212135235223.png)

## 总结

![image-20220212135407059](images\image-20220212135407059.png)

双端、无环、带表头表尾指针、长度计数器、多态。

# 字典

**redis数据库**底层使用字典实现，哈希键的底层实现之一

**由字典、哈希表、哈希表节点组成**

## 哈希表

![image-20220212140142444](images\image-20220212140142444.png)

## 哈希表节点

![image-20220212140214650](images\image-20220212140214650.png)

## 哈希冲突

冲突则使用链表next指针关联起来

![image-20220212140400005](images\image-20220212140400005.png)

table 哈希表、size：table的大小、sizemask：size-1、used：已用

## 字典

![image-20220212140424404](images\image-20220212140424404.png)

作用是存放两个哈希表，和rehash，用于哈希表的负载因子维持在一个合理范围，当保存的键值对数量多或者少，会对哈希表的大小进行合理扩缩容。rehash：对第二个表根据第一个表进行扩缩容后，将第一个哈希表的键值重新hash到第二个哈希表中。

- 扩容，则是已用大小*2 ，再向上取，取到2的幂次值。缩容，则是已用的向上取整，取到2的幂次值。2的幂次是为了计算键的位置（hash与sizemask取余）的优化

## 渐进式rehash

rehash式分多次、渐进式地完成。因为千万，亿级别地rehash会导致服务器一段时间无法提供服务。两个哈希表ht[0]，ht[1]

- rehash期间，收到请求对字典的操作，会顺带将涉及到的键值对rehash到ht[1]中
- rehash期间，字典会对两个哈希表同时进行操作，在0找不到则会到1找。

# 跳跃表

用于有序集合键的底层实现之一。

**由跳跃表节点和跳跃表头组成**，原理其实是增加索引的目的来实现链表的快速查找。平均O(logn)，最坏O(n)的查找

## 跳跃表头

![image-20220212142821115](images\image-20220212142821115.png)

## 跳跃表节点

![image-20220212142927311](images\image-20220212142927311.png)

层：这个节点有多少层，每层都有前进指针，即该指针指向下一个节点的跨度

后退指针，只有一个后退指针，指向上一个节点。

分值、成员对象。

# 整数集合

用于保存整数值的抽象数据结构

![image-20220212143143892](images\image-20220212143143892.png)

contents的元素大小，由encoding决定，如果encoding是intset_enc_int16，则整数集合的底层实现是int16_t。

## 升级

必须保证contents的元素类型一致，即要么都是int16，要么都是int32。如果新增加一个元素是int32到int16的content中，那么整个contents都需要升级。

- 灵活：通过自动升级来适应新元素。
- 节约内存：由int16  int32   int64，如果随意类型，那么只能使用int64来存储，那么必然会导致内存浪费。

## 降级

不会降级

# 压缩列表

列表键和哈希键的底层实现之一。当列表只包含少量列表项，且每个列表项都是小整数值、比较短的字符串。

内存连续的。

![image-20220212144740213](images\image-20220212144740213.png)

zltail 表尾节点是指entryN，压缩列表的起始地址是zlbytes

## 压缩列表节点

![image-20220212145017723](images\image-20220212145017723.png)

previous_entry_length ：记录上一个节点的长度。用于当前节点的起始指针 - 该值 = 上一个节点的起始指针。

## 连锁更新

因为previous_entry_length记录上个节点的长度，如果上个节点扩容，将导致当前节点该值扩容。实际并不多见，且只要被更新节点不多，就不会对性能造成影响。

## 例子

```js
lpush list 1 2 3 
object encoding list
```

# 对象

创建一个键值对时，至少创建两个对象。一个是键，一个是值。

每一个对象都是redisObject

![image-20220306204944122](E:\dailynote\redis\images\image-20220306204944122.png)

## 类型

`type xx`

## 字符串对象

编码：`int 、raw 、embstr`

- 数值类型且用long表示，则encoding为int，ptr为数值。
- 字符串且长度大于32字节，则encoding为raw，ptr指向sds。
- 字符串且长度小于等于32字节，则encoding为embstr，ptr指向sds。

raw和embstr的区别：为redisObject和sdshdr结构分配内存和回收时，raw都经历两次分配两次释放。而embstr则都为一次。

**字符串对象是redis物种类型对象中唯一一种会被其他四种类型对象嵌套的对象**

![image-20220306210441245](E:\dailynote\redis\images\image-20220306210441245.png)

![image-20220306210428893](E:\dailynote\redis\images\image-20220306210428893.png)

![image-20220306210451244](E:\dailynote\redis\images\image-20220306210451244.png)

转化

- long类型用int编码
- long double保存的浮点数，用embstr或者raw
- 字符串值或因长度太大无法用long类型的整数或者浮点数，用embstr或者raw

## 列表对象

编码：`ziplist、linkedlist`

![image-20220306210528484](E:\dailynote\redis\images\image-20220306210528484.png)

![image-20220306210536638](E:\dailynote\redis\images\image-20220306210536638.png)

转化：

- 列表保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素小于512个。

则才能从linkedlist转为ziplist

## 哈希对象

编码：`ziplist 、 hashtable`

使用ziplist时，哈希的键值分别是两个节点，紧挨着的。

![image-20220306211506072](E:\dailynote\redis\images\image-20220306211506072.png)

![image-20220306211647236](E:\dailynote\redis\images\image-20220306211647236.png)



转化：

- 哈希对象保存的所有键值对的所有键和值长度都小于64字节。
- 键值对数量小于512.

满足以上两个对象，hashtable才能转ziplist

## 集合对象

编码`intset、hashtable`

用hashtable时，字典的值都是null。键都是一个字符串对象，每个字符串对象包含一个集合元素。

![image-20220306212836524](E:\dailynote\redis\images\image-20220306212836524.png)

转化：

- 集合对象保存所有的元素都是整数值。
- 集合对象保存的元素不超过512个。

不满足以上条件的集合对象必须使用hashtable编码。

## 有序集合

编码：`ziplist、skiplist`

使用ziplist时，有序集合元素有 元素成员 + 元素分值。 会被拆成两个节点，两个节点紧挨着保存在压缩列表中。

![image-20220306213335470](E:\dailynote\redis\images\image-20220306213335470.png)

![image-20220306213326276](E:\dailynote\redis\images\image-20220306213326276.png)

使用skiplist编码，使用的是zset结构，zset结构是同时包含字典和跳跃表。

- 跳跃表用于实现范围型操作，比如zrank、zrange等api。

- 字典表存储成员到分值的映射，通过O（1）找到成员分数。

两种数据结构都会通过指针来共享相同元素的成员和分值，因此不会产生任何重复的成员和内存，因此不会有额外的内存消耗。

转化：

- 有序集合保存的元素数量小于128个
- 有序结合保存的所有元素成员的长度都小于64字节。

满足以上的有序集合将使用skiplist.
