# 数据模型

内嵌结构（文档中内嵌文档）、规范式结构（分为 两个集合，用objectId关联两个文档）

一对一：使用内嵌结构

一对多：可以使用内嵌，也可以使用规范。

使用内嵌：则更新时需要更新多个文档。使用规范式：则查询时需要聚合的lookup

多对多：

树形结构：

- 子存放所有父的id（parent:[]）。子找到所有父，根据数组即可。父找到子，`parent include  cid`
- ![image-20220213171400418](E:\dailynote\MongoDB\img\image-20220213171400418.png)

先深度遍历好给每个节点都标上 左右值。

要找某个节点的所有子节点：满足子节点 左边大于父节点的左边 **且** 子节点的右边小于父节点的右边。

要找某个节点的所有父节点：满足父节点的左边小于子节点的左边  **且**  父节点的右边大于子节点的右边。

# 数据复制

## 优点：

数据分发：数据被分发到不同区域，用户不需要跨区访问数据。

读写分离：

异地容灾：某地故障，可以迅速切换到另一地方。

## 数据复制过程

主节点记录到oplog，从节点在主节点打开一个tailable游标，不断获取新进入主节点的oplog，然后在自己数据上回放，以此保持数据一致。

## 故障恢复

前提：具有投票权的节点两两互发心跳。5次心跳未收到则判断为节点失联。

主节点失联则从节点发起选举，选出主节点。从节点失联，不会重新选举。

基于RAFT一致性算法，选举成功必须条件是大多数投票节点存活。

复制集中最多可以有50个节点。具有投票权的节点最多只有7个。

## 影响选举因素

过半的节点存活。

能被选举为主节点的节点，必须：

- 能与多数节点建立连接。
- 具有教新的oplog
- 具有较高的优先级

复制节点常见选配项（config.members[x].fieldName = ）

- 是否具有投票权
- 优先级
- 隐藏：节点具有投票权，但优先级为0
- 延迟：复制n秒前的数据，主从保持时间差。

## 触发选举

- 主节点与从节点之间心跳请求超时

- 复制集初始化

- 新节点加入复制集

# 数据分片

一个mongo横向扩展需要：分片、配置服务器、mongos、主分片

- 每个分片只存储一部分数据，可以为每个分片部署复制集
- mongos路由将客户的请求发送至相关的分片
- 配置服务器保存集群配置和元数据，可以部署为复制集
- 集群中的每个数据库都会选择一个分片作为主分片，主分片存储所有不需要分片的集合，创建数据库时，数据最少的分片被选为主分片。



分片片键