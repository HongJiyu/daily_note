# 数据模型

内嵌结构（文档中内嵌文档）、规范式结构（分为 两个集合，用objectId关联两个文档）

一对一：使用内嵌结构

一对多：可以使用内嵌，也可以使用规范。

使用内嵌：则更新时需要更新多个文档。使用规范式：则查询时需要聚合的lookup

多对多：

树形结构：

- 子存放所有父的id（parent:[]）。子找到所有父，根据数组即可。父找到子，`parent include  cid`
- ![image-20220213171400418](E:\dailynote\MongoDB\img\image-20220213171400418.png)

先深度遍历好给每个节点都标上 左右值。

要找某个节点的所有子节点：满足子节点 左边大于父节点的左边 **且** 子节点的右边小于父节点的右边。

要找某个节点的所有父节点：满足父节点的左边小于子节点的左边  **且**  父节点的右边大于子节点的右边。

# 数据复制

## 优点：

数据分发：数据被分发到不同区域，用户不需要跨区访问数据。

读写分离：

异地容灾：某地故障，可以迅速切换到另一地方。

## 数据复制过程

主节点记录到oplog，从节点在主节点打开一个tailable游标，不断获取新进入主节点的oplog，然后在自己数据上回放，以此保持数据一致。

## 故障恢复

前提：具有投票权的节点两两互发心跳。5次心跳未收到则判断为节点失联。

主节点失联则从节点发起选举，选出主节点。从节点失联，不会重新选举。

基于RAFT一致性算法，选举成功必须条件是大多数投票节点存活。

复制集中最多可以有50个节点。具有投票权的节点最多只有7个。

## 影响选举因素

过半的节点存活。

能被选举为主节点的节点，必须：

- 能与多数节点建立连接。
- 具有教新的oplog
- 具有较高的优先级

复制节点常见选配项（config.members[x].fieldName = ）

- 是否具有投票权
- 优先级
- 隐藏：节点具有投票权，但优先级为0
- 延迟：复制n秒前的数据，主从保持时间差。

## 触发选举

- 主节点与从节点之间心跳请求超时

- 复制集初始化

- 新节点加入复制集

# 数据分片

一个mongo横向扩展需要：分片、配置服务器、mongos、主分片

- 每个分片只存储一部分数据，可以为每个分片部署复制集
- mongos路由将客户的请求发送至相关的分片
- 配置服务器保存集群配置和元数据，可以部署为复制集
- 集群中的每个数据库都会选择一个分片作为主分片，主分片存储所有不需要分片的集合，创建数据库时，数据最少的分片被选为主分片。 

## 分片片键

分片上还有数据段。

- 片键值用来将集合的文档划分为数据段
- 片键必须对应一个索引或者索引前缀（单键或复合键）
- 可以使用片键值的哈希值生成哈希片键

选择片键

- 范围要广（使用复合片键扩大范围）
- 分布平衡（使用复合片键）
- 不要单向增大/减小（可用哈希片键）

分片有数据段。

- 数据段分裂，通过更新元数据实现。
- 后台运行的平衡器负责监视和调整集群平衡（各个分片的数据段的平衡）
- 当最大和最小分片之间的数据段数量相差过大时，触发平衡器。
- 集群中添加或移除分片时也会触发

## 配置服务器

存储各分片数据段列表和数据段范围，存储集群的认证和授权配置，不同集群不要共用配置服务器

## mongos

mongos作为路由

- 查询包含分片片键，将查询发送到指定分片
- 无包含分片片键，mongos将查询发送给所有分片，并汇总所有结果。

# 数据安全（略，角色）

# 管理工具

## 数据处理工具

## 监控工具

mongostat  显示数据库服务器进程状态

mongotop 显示各个集合上的读写时间

## 故障诊断

响应慢

- 内存配置：wiredTiger-engineConfig-cacheSizeGB ，mongostat来诊断内存情况
- 索引

连接失败

- db.serverStatus().connections
- 连接配置： net-maxIncomingConnections
- ulimit -a    连接消耗文件描述符，查看系统支持的文件描述符数量