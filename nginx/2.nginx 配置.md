# nginx进程间的关系

worker和master的关系。

worker尽量和cpu数量一致。（最好每一个worker进程都绑定特定的cpu核心），进程间特换代价最小。

# nginx配置的通用语法

## 块配置项

由块配置项名和一对大括号组成。

![image-20210603202819192](D:\note\nginx\images\image-20210603202819192.png)![image-20210603202852819](D:\note\nginx\images\image-20210603202852819.png)

- 上面代码段中events、http、server、location、upstream 都是块配置项，至于后面是否要加参数，如： backend ，、webstatic ，这取决于解析这个块配置项的模块，不能一概而论。

- 块配置项可以嵌套，内层直接继承外层块。server块的任意配置都是基于http块里已有的配置。如果冲突，取决于解析这个配置项的模块。如location和http块的gzip冲突，这时，在处理/webstatic模块时，gzip是按照gzip off处理请求的。

## 配置项语法格式

- 配置项名 必须是nginx某个模块想要处理的，否则会认为配置文件出现了非法的配置项名。

- 配置项名 输入后，必须以空格作为分隔符。

- 配置项值，可以是数字或字符串或正则，可以有一个值或多个值，值之间也用空格符分隔。

- 每行配置的结尾要加上分号
- 配置项值中有语法符号：空格，那么需要用单引号或双引号括住。

如下：

`log_format main '$remote_addr - $remote_user [$time_local] "$request" '`

## 配置项注释

使用#

## 配置项的单位

大模块遵循一些通用的规定，如空间不用每次定义到字节，时间不用精确到毫秒。

- 空间：K或者k （KB）  
- 时间：ms,s,m,h,d,w,M,y （毫秒，秒，分，时，天，周7天，月30天，年365天）

是否可以用这些单位，取决于解析该配置项的模块。只有这个模块使用了nginx框架提供的相应解析配置项方法，配置项值才可以携带这些单位。

## 配置项中使用变量

需要加上 $ 如：$remote_addr

![image-20210604173503967](D:\note\nginx\images\image-20210604173503967.png)

# nginx服务的基本配置

nginx在运行时，至少必须加载几个核心模块和事件类模块，这些模块运行时所支持的配置项称为基本配置——其他模块执行都依赖的配置项。

分为四类：

- 用于调试、定位的
- 正常运行必备的
- 优化性能的
- 事件类配置

有一些即使没有显式配置，也会有默认值，如daemon，即使在nginx.conf没有进行配置，也相当于打开了这个功能。

## 调试进程和定位问题

- 是否以守护进程方式运行 ： daemon on|off ; ，默认 daemon on;
- 是否以master/worker方式工作： master_process on|off;  默认  master_process on;
- error日志设置： error_log pathfile level; 默认 error_log logs/error.log error;

如果 pathfile为/dev/null ，就不会输出任何日志，这也是关闭error的唯一手段。 也可以为 stderr，这样会输出到标准错误文件中。

level 范围： debug、info、notice、warn、error、crit、alert、emerg。 当设定为某个级别时，大于或等于该级别的日志才会输出到指定文件。

如果设置到debug，必须在configure时加入 ： --with-debug，配置项。

- 指定客户端输出debug级别日志：  debug_connection <ip|cidr>;

```shell
events {
	debug_connection 10.224.66.14;
	debug_connection 10.224.57.0/24;
}
```

该配置实际是事件类配置，不过用户定位问题，这样，以上ip地址会输出debug级别日志，其他请求沿用error_log配置的日志级别。

如果设置到debug_connection，必须在configure时加入 ： --with-debug，配置项。

- 限制coredump核心转储文件大小： worker_rlimit_core size;

nginx进程出现非法操作（内存越界）导致直接被操作系统强制结束，会生成核心转储core文件，从中可以获取当时堆栈、寄存器信息。但是有很多其他信息，如果不限制，几次后就会占满磁盘。

- 指定coredump文件生成目录： working_directory path;

worker进程的工作目录，防止coredump文件放置目录

## 正常运行的配置项

- 定义环境变量 ：  env  xx=xx;

让用户直接设置操作系统上的环境变量

- 嵌入其他配置文件： include pathfile;

将其他配置文件嵌入到nginx.conf文件，参数可以是相对或绝对。可以包含通配符*，同时一次嵌入多个配置文件。

```shell
include mime.types
include vhost/*.conf
```

- pid路径 ： pid path/file;  默认：pid logs/nginx.pid;

保存master进程id的pid文件存放路径。默认与configure执行时的参数 --pid-path一致，该文件直接影响nginx是否可以运行。

- nginx worker进程运行的用户及用户组。user username [groupname]; 默认 user nobody nobody;

用于设置master进程启动后，fork出的worker进程运行在哪个用户和用户组下。当按照 user username; 设置，用户组和用户名相同

在configure执行时使用 --user=username  和--group=groupname，则nginx.confg使用参数指定的。

- nginx worker 进程可以打开的最大句柄描述符个数。 worker_rlimit_nofile limit;
- 限制信号队列 。 worker_rlimit_sigpending limit;

设置每个用户发往nginx信号队列的大小。当某个用户的信号队列满了，该用户再发送的信号量会被丢掉。

## 优化性能的配置项

- nginx worker进程个数。 worker_processes number; 默认： worker_processes 1;
- 绑定 worker进程到指定的cpu内核：worker_cpu_affinity cpumask [cpumask...];

liunx是抢占式的，如果多个worker都在抢一个cpu，就会出现同步问题。如果每个worker进程独享一个cpu，在内核调度策略上实现完全的并发。

```shell
worker_processes 4;
worker_cpu_affinity 1000 0100 0010 0001;
```

linux通过sched_setaffinity()调用实现该功能。

- ssl硬件加速：ssl_engine device;

如果服务器上有ssl硬件加速设备，则可以配置以加快ssl协议的处理速度。通过`openssl engine -t`查看是否有ssl硬件加速设备。

- 系统调用gettimeofday的执行频率：timer_resolution t;

更新时间的频率，早期比较耗时，现在代价不大。如果期望日志时间更准确，可以使用。 

- nginx worker 进程优先级设置： worker_priority nice; 默认：worker_priority 0;

操作系统上有很多进程，都处于可执行状态，将按照优先级来决定内核选择哪一个进程。（默认，最小时间片只有5ms，最大有800ms）。优先级由 静态优先级+进程执行情况动态调整（上下5ms的调整）。

取值范围由 -20~19. -20最高 ，+19最低。可以把值调小，以保证获得更多资源。但不建议比内核进程小（-5）

## 事件类配置项

- 是否打开accept锁：accept_mutex <on|off> 默认 accept_mutext on;

用于nginx 负载均衡的，第9章讲，可以让多个worker进程轮流与新客户端建立tcp连接。当一个worker进程建立的数量达到worker_connections配置的最大连接的 7/8时，会大大减少该worker进程试图建立新tcp连接的机会，以保证所有worker进程维持的连接数接近。

默认打开，关闭会使建立tcp连接耗时更短，但不建议。

- lock文件的路径：lock_file path/file; 默认：lock_file logs/nginx.lock;

accept锁可能需要这个lock文件，如果accept锁关闭，一定不需要用到该文件，如果开启了accept锁，又因为编译程序、操作系统架构等原因导致nginx比支持原子锁，这时才会通过文件锁实现accept锁，该文件才会生效。

- accept锁后到真正建立连接之间的延迟时间：accept_mutex_delay Nms; 默认：accept_mutex_delay 500ms;

同一时间只有一个worker进程能够获取到accept锁，accept不是阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图获取accept而没取到，至少要accept_mutex_delay定义的时间间隔才能再次试图获取锁。

- 批量建立新连接：multi_accept [on|off]; 默认：multi_accept off;

当事件模型通知有新连接时，尽可能对本次调度中客户端发起的所有tcp请求都建立连接。

- 选择事件模型： use[kqueue|rtsig|epoll|/dev/poll|select|poll|eventport]；默认 nginx自动选择。

linux操作系统可供选择有三种（poll、select、epoll），epoll性能最高，9.6节讲。

- 每个worker的最大连接数： worker_connections number;

# 用http核心模块配置静态web服务器

主要由ngx_http_core_module模块实现。

所有的http配置项都必须直属于http块、server块、location块、upstream块或if块（http配置项自然必须全部在http{}块内，直属于是指配置项项直接所属的大括号对应的模块配置）

讲这些配置项分为以下八类

## 虚拟主机与请求分发

用一台nginx可以处理不同主机域名的请求，在nginx.conf按照server_name（用户请求中的主机域名）并通过server块来定义虚拟主机，每个server块就是一个虚拟主机，它只处理与之相应的主机域名请求。

### 监听端口

语法：listen address:port [default(deprecated in 0.8.21)|default_server] [backlog=num|rcvbuf=size|sndbuf=size|accept_filter|deferred|bind|ipv6only=[on|off|ssl]]

默认：listen 80;

配置块：server，决定nginx服务如何监听端口。可以只加ip地址、端口或主机名。

![image-20210606113105953](D:\note\nginx\images\image-20210606113105953.png)

- default和default_server：讲所在的server块作为整个web服务的默认server块。如果都没有设置这个参数，那么会采用第一个server作为默认块。当一个请求无法匹配配置文件中的所有主机域名，就会选用默认的虚拟主机。
- backlog=num:表示tcp中backlog队列大小，默认是-1，不予设置。tcp建立三次握手过程，进程还没有处理监听句柄，这时backlog队列会防止这些新连接。如果backlog队列满了，还有新的客户端试图建立三次握手建立tcp连接，则会失败。
- rcvbuf=size：设置监听句柄SO_RCVBUF参数。
- sndbuf=size：设置监听句柄的SO_SNDBUF参数。
- accept_filter：设置accept过滤器，指对FreeDSD操作系统有用。
- deferred：用户发起连接请求，并且完成了tcp三次握手，内核也不会为了这次连接调度worker进程来处理，只有用户真正发送请求（内核已经在网卡中受到请求数据包），内核才会唤醒worker进程处理连接，适用于大并发，减轻worker进程的负担。
- bind：绑定当前端口/地址对，如：127.0.0.1:8000。只有同时对一个端口监听多个地址才会生效。
- ssl：在当前监听的端口上建立连接必须基于ssl协议。

### 主机名

语法：server_name \<name\>;

默认：server_name "";

配置快：server

server_name 后可以跟多个主机名称，如`server_name www.testweb.com、download.testweb.com;`

在开始处理一个http请求时，会取出header头中的Host，与每个server进行匹配，有可能一个Host与多个server块中的server_name都匹配，那么会有优先级。

- 优先选择所有字符串完全匹配的server_name。
- 选择通配符在前面的，如：*.testweb.com。
- 选择通配符在后面的，如：www.testweb.*。
- 最后选择正则匹配的，如：~^\.testweb\.com$

如果Host和所有server_name都不匹配，那么会按照下列顺序选择处理。

- 优先选择listen配置项后面加入[default|default_server]的server块。
- 找到匹配listen端口的第一个server块。

如果server_name后跟着空字符串（server_name "";），那么匹配没有Host这个http头部的请求。

### server_names_hash_bucket_size

为了提高快速寻找server name的能力，naginx使用散列表来存储server name。它用来设置每个散列桶占用内存的大小。

语法：server_names_hash_bucket_size size;

默认：server_names_hash_bucket_size 32|64|128；

配置块：http、server、location

### server_names_hash_max_size

语法：server_names_hash_max_size size;

默认：server_names_hash_max_size 512;

配置快：http、server、location

server_names_hash_max_size影响散列表的冲突率。server_names_hash_max_size越大，消耗内存越多，散列key的冲突率越低，检索速度越快。

### server_name_in_redirect;

重定向主机名称的处理。

语法：server_name_in_redirect on|off;

默认：server_name_in_redirect on;

配置快：http、server或者location

该配置需要配合server_name使用。在on打开时，表示重定向请求时会使用server_name里配置的第一个主机名替代请求原先的Host头部，而使用off关闭时，表示重定向请求时使用请求本身的Host头部。

### location

语法：location [=|~|~*|^~|@]  /uri/{...}

配置块：server

location会尝试根据用户请求中的URI来匹配上面的/uri 表达式，如果可以匹配，就选择location{}块中的配置来处理用户请求。

- =号：讲uri当作字符串表示，以便与参数中的uri做完全匹配。
- ~号：表示匹配URI时是字母大小写敏感的。
- ~*：表示匹配URI时忽略字母大小写问题。
- ^~：表示匹配URI时只需要前半部分与uri参数匹配即可。
- @：表示内部请i去之间的重定向，带有@的location不直接处理用户请求。

uri中也可以使用正则，如：`location ~* \.(gif|jpg|jpeg)$ { }`

注意，location是可以有顺序的，当一个请求有可能匹配多个locaiton时，实际这个请求会被第一个location处理。

nginx很难实现 如果不匹配则。。，只有将 `locaiton / {}`放到最后，表示，如果前面的都不匹配，则由这个loction处理。

## 文件路径的定义

讲文件路径的定义配置项

### 以root方式设置资源路径

语法：root path;

默认：root html;

配置块：http、server、location、if

```shell
location /download {
	root optwebhtml;
}
```

如果由一个请求的uri时/download/index/test.html，那么web服务器将会返回 /optwebhtml/download/index/test.html 文件的内容。

### 以alia方式设置资源路径

语法：alias path;

配置块：locaiton

如果用户请求的uri是/conf/nginx.conf，配置：

```shell
locaiton conf  {
	alias user/local/nginx/conf;
}
```

则该请求会被转化为： /usr/location/nginx/conf/nginx.conf

alias后面还可以添加正则表达式，例如：

```shell
location ~ ^/test/(\w+)\.(\w)$ {
	alias usr/local/nginx/$2/$1.$2;
} 
```

这样，访问/test/nginx.conf，nginx会返回 /usr/local/nginx/conf/nginx.conf

### 访问首页

语法：index file ...;

默认：index index.html;

配置块：http、server、location

访问站点URI是/ ,这时一般是返回网站首页，这与root和alias不同，这里用 ngx_http_index_moudle提供的index配置实现。index后跟多个文件参数，nginx会按顺序访问这些文件

```shell
location {
	root path;
	index index.html html/index.php /index.php;
}
```

接收到请求后，会先尝试访问path/index.php ，否则再试图访问 path/html/index.php

### 根据http返回码重定向页面

语法：error_page code [code...] [=|=answer-code] uri|@named_location

配置块：http、server、location、if

对于某个请求返回错误码时，如果匹配上了error_page中设置的code，则重定向到新的URI中，例如：

```shell
error_page 404 404.html;
error_page 502 503 504 50x.html;
error_page 403 http://example.com/forbidden.html;
error_page 404 = @fetch;
```

注意，虽然重定向了URI，但是返回的http错误码还是与原来的相同。用户可以通过=来更改返回的错误码，例如：

```shell
error_page 404 =200 empty.gif;
error_page 404 =403 forbidden.gif;
```

也可以不指定确切的返回错误码，而是由重定向后实际处理的真实结果来决定，这时，只需要把=后面的错误码去掉即可，例如：

```shell
error_page 404 = /empty.gif;
```

如果不想修改uri，而是让请求重定向到另一个location中进行处理，那么：

```shell
location / {
	error_page 404 @fallback;
}
location @fallback {
	proxy_pass http://backend;
}
这样返回404的请求会被反向代理到http://backend 上游服务器上处理。
```

### 是否允许递归使用error_page

语法：recursive_error_pages [on|off];

默认：recursive_error_pages off;

配置块：http、server、location

确定是否允许递归地定义error_page。

### try_files

语法： try_files path1 [path2] uri;

配置块：server、location

后面要跟若干路径，如path1，path2，而且最后必须要有uri参数。意义：尝试顺序访问每一个path，如果有效读取，则直接向用户返回这个path对应地文件结束请求，否则继续向下访问。如果所有的path都找不到有效文件，则重定向都最后的参数uri上。因此uri时必须存在，且可以有效重定向。

```shell
try_files system/maintenance.html $uri $uri/index.html $uri.html @other;
location @other {
	proxy_pass http://backend
}
```

## 内存及磁盘资源的分配

下面介绍处理请求时内存、磁盘资源分配的配置项

### 存储http头部的内存buffer大小

语法：client_heaer_buffer_size size;

默认：client_heaer_buffer_size 1k;

配置块：http、server

上面配置项定义了正常情况下nginx接收用户请求中http header部分（http行和头部）时分配的内存buffer大小。

### 存储超大http头部的内存buffer大小

语法：large_client_header_buffers number size;

默认：large_client_header_buffers 58k;

默认配置块：http、server

定义了nginx接收一个超大http头部请i去的buffer个数和每个buffer大小。如果请求行大小超过单个buffer，返回"request uri too large"(414)。请求由许多header，每一个header大小不能超过单个buffer大小，否则返回”bad request“（400）.请求行和请求头的综合也不可以超过buffer个数*buffer大小。

### http包体存储到磁盘文件中

语法：client_body_in_file_only on|clean|off;

默认：client_body_in_file_only off;

配置块：http、server、location

当值为非off时，会将请求的http包都放到磁盘文件，即使只有0字节。请求结束，如果配置为on，则文件不会被删除，如果为clean，则会被删除。

### http包体尽量写入到一个内存buffer中

语法：client_body_insingle_buffer on|off;

默认：client_body_insingle_buffer off;

配置块： http、server、location

用户请求中的http包一律存储在内存buffer中。如果http包体超过下面的配置（client_body_buffer_size），也还是会写入磁盘文件中。

### 存储http包体的内存buffer大小

语法：client_body_buffer_size size;

默认：client_body_buffer_size 8k/16k;

配置块：http、server、location

http包体会先接收到指定的这块缓存中，之后才决定是否写入磁盘。

注意：如果用户请求中含有Content-Length，并且其标识的长度小于定义的buffer大小，那么nginx会自动降低本次请求所使用的内存buffer，以降低内存消耗。

### http包体的临时存放目录

语法：client_body_temp_path dir-path [level1[level2[level3]]]

默认：client_body_temp_path client_body_tmp;

配置块：http、server、location

如果包体的大小大于client_body_buffer_size，则会以一个递增的整数命名并存放到client_body_temp_path指定的目录中。后面跟着level，是为了防止一个目录下的文件数量太多，导致性能下降，这样可以按照临时文件名最多再加三层目录。

```shell
client_body_temp_path optnginx/client_tmp 1 2;
```

新上传的http包体是00123456作为文件名，则存放在这个目录下

```shell
optnginx/client_tmp/6/45/00123456
```

### connection_pool_size

语法：connection_pool_size size;

默认：connection_pool_size 256;

配置块：http、server

nginx为每个建立成功的tcp连接会预先分配一个内存池，size配置将指定这个内存池的初始化大小。（即ngx_connection 结构体中pool内存池初始化大小），连接关闭会销毁

### request_pool_size

语法：request_pool_size size;

默认：request_pool_size 4k;

配置块：http、server

nginx为每个请求分配一个内存池（即ngx_http_request结构体中pool内存池初始化大小），请求结束会销毁。

## 网络连接设置

- client_header_timeout time;
- client_body_timeout time;
- send_timeout time;
- reset_timeout_connection on|off;
- lingering_close off|on|always;
- lingering_time time;
- lingering_timeout time;
- keepalive_disable [msie6|safari|none];
- keepalive_timeout time;
- keepalive_requests n;
- tcp_nodelay on|off;
- tcp_nopush on|off;

## mime类型设置



