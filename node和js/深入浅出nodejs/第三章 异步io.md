Node的特点：

事件驱动、异步io

事件驱动：监听事件的变化来进行应用的流程控制。

异步io：网络模型。

# 前提

阻塞和非阻塞：

- 阻塞：当前线程发起请求会阻塞当前线程，等待请求完成才可以继续执行。
- 非阻塞：当前线程发起请求，对方直接响应，大部分响应的是类似：还在处理中的中间状态。

同步和异步：

- 同步：调用方会去等待结果，从阻塞、非阻塞（轮询、休眠），直到获取到结果。
- 异步：调用方会去执行其他操作。等到通知后才会执行方法的回调。

# 为什么要单线程异步

- 单线程同步模型：无法充分使用cpu资源：因为同步，所以在io时，会等待io执行完成。而cpu会去调度其他进程。

- 多线程同步模型：可以充分使用cpu资源，但是存在并发问题，死锁等情况。

- node：利用单线程远离多线程并发问题，同时使用过异步让线程远离阻塞，更好使用单核cpu资源。

# 必须去了解

阻塞io和非阻塞io

- 阻塞io需要一直等待数据返回。
- 非阻塞io：需要去轮询数据是否完成。read（一直轮询），select（通过文件描述符判断，数组存储），poll（链表存储），epoll（休眠，不会遍历查询，等到事件唤醒他。）

以上仍然属于同步，因为需要等待数据完成，cpu要么用于遍历，要么休眠等待。

# 理想的异步io

在进行io时，仅仅进行非阻塞调用，然后cpu执行后续其他操作，而不是遍历查询或者是休眠。而是可以继续执行用户代码。

linux下存在，但是仅支持内核io中的O_DIRECT方式读取，导致无法利用系统缓存。

# 现实的异步io

实际还是通过线程池实现的异步io，

- 通过让部分线程进行阻塞io或者非阻塞io加轮询技术完成数据获取。
- 让一个线程进行计算处理
- 通过线程之间的通信将io得到的数据进行传递，实现异步io。

![image-20201111205623558](E:\0git_note\node和js\深入浅出nodejs\image\image-20201111205623558.png)

# Node的异步io

1. 事件循环

2. 观察者（可以简单理解为队列或数组）

3. 请求对象
4. io线程池

windows下主要通过iocp向系统内核发送io调用和从内核获取已完成的io操作。而linux则通过epoll实现这个过程。

# Node非io的异步api

1. 定时器：setTimeout和setInterval =》红黑树存储。
2. nextTick：数组。

3. setImmediate：链表。每次只执行一个，例子：用nextTick插入。
4. promise