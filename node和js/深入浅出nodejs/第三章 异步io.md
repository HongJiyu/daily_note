# 前提

同步和异步：

- 同步：调用方一直等待结果。
- 异步：被调用方通知调用方执行结束。

阻塞和非阻塞：

- 阻塞：操作会阻塞线程，无法执行其他操作。
- 非阻塞：操作不会阻塞线程。

# 为什么要单线程异步

- 单线程同步模型：无法充分使用cpu资源：因为同步，所以在io时，会等待io执行完成。而cpu会去调度其他进程。

- 多线程同步模型：可以充分使用cpu资源，但是存在并发问题，死锁等情况。

- node：利用单线程远离多线程并发问题，同时使用过异步让线程远离阻塞，更好使用单核cpu资源。

# 必须去了解

阻塞io和非阻塞io

- 阻塞io需要一直等待数据返回。
- 非阻塞io：需要去轮询数据是否完成。read（一直轮询），select（通过文件描述符判断，数组存储），poll（链表存储），epoll（休眠，不会遍历查询，等到事件唤醒他。）

以上仍然属于同步，因为需要等待数据完成，cpu要么用于遍历，要么休眠等待。

# 理想的异步io

在进行io时，仅仅进行非阻塞调用，然后cpu执行后续其他操作，而不是遍历查询或者是休眠。而是可以继续执行用户代码。

linux下存在，但是仅支持内核io中的O_DIRECT方式读取，导致无法利用系统缓存。

# 现实的异步io



