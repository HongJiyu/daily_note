# 前提

阻塞和非阻塞：

- 阻塞：当前线程发起请求会阻塞当前线程，等待请求完成才可以继续执行。
- 非阻塞：当前线程发起请求，对方直接响应，大部分响应的是类似：还在处理中的中间状态。

同步和异步：

- 同步：调用方会去等待结果，从阻塞、非阻塞（轮询、休眠），直到获取到结果。
- 异步：调用方会去执行其他操作。等到通知后才会执行方法的回调。

# 为什么要单线程异步

- 单线程同步模型：无法充分使用cpu资源：因为同步，所以在io时，会等待io执行完成。而cpu会去调度其他进程。

- 多线程同步模型：可以充分使用cpu资源，但是存在并发问题，死锁等情况。

- node：利用单线程远离多线程并发问题，同时使用过异步让线程远离阻塞，更好使用单核cpu资源。

# 必须去了解

阻塞io和非阻塞io

- 阻塞io需要一直等待数据返回。
- 非阻塞io：需要去轮询数据是否完成。read（一直轮询），select（通过文件描述符判断，数组存储），poll（链表存储），epoll（休眠，不会遍历查询，等到事件唤醒他。）

以上仍然属于同步，因为需要等待数据完成，cpu要么用于遍历，要么休眠等待。

# 理想的异步io

在进行io时，仅仅进行非阻塞调用，然后cpu执行后续其他操作，而不是遍历查询或者是休眠。而是可以继续执行用户代码。

linux下存在，但是仅支持内核io中的O_DIRECT方式读取，导致无法利用系统缓存。

# 现实的异步io

实际还是通过线程池实现的异步io，

![image-20201110092145802](D:\note\node和js\深入浅出nodejs\image\image-20201110092145802.png)