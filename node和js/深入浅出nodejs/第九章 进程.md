用户代码会运行在单进程的单线程上

- 如果单线程异常没有被捕获，将引起真个进程奔溃。
- 同时单进程无法充分利用cpu资源。

node通过异步io和事件驱动，使得在单进程单线程便能够支撑高并发。而创建子进程是为了充分利用cpu资源和保证系统健壮。

# 创建子进程

![image-20201128114034011](D:\note\node和js\深入浅出nodejs\image\image-20201128114034011.png)

JavaScript文件通过execFile运行，它的首行内容必须添加如下代码：

`#!/usr/bin/env node`

## 进程间通信

```js
// parent.js
var cp = require('child_process');
var n = cp.fork(__dirname + '/sub.js');
n.on('message', function (m) {
 console.log('PARENT got message:', m);
});
n.send({hello: 'world'});

// sub.js
process.on('message', function (m) {
 console.log('CHILD got message:', m);
});
process.send({foo: 'bar'}); 
```

父子进程通过事件监听机制实现通讯。其底层是IPC （Inter-Process Communication）

进程间通讯。

node实现ipc通道是使用管道技术（抽象称呼），具体是由libuv实现，在windows下由命名管道实现，在*nix系统采用unix domain socket实现。而在应用层表现为简单的message和send。

![image-20201128132713479](D:\note\node和js\深入浅出nodejs\image\image-20201128132713479.png)

父进程创建子进程之气那，会先创建ipc通道并监听，然后才创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个ipc的文件描述符。子进程启动后通过描述符链接这个ipc通道，进而完成链接。

这个连接属于双向，同时在node中ipc通道被抽象成stream对象，因此send和message事件就像事件监听机制一样。

my.hoopchina.com/dcjc





tcp服务器端的socket套接字的文件描述符并不相同，导致监听相同端口抛出异常。