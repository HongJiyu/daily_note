http要传送一条报文，tcp会将数据流砍成小数据块（段），并封装到ip分组中，再进行传输。

tcp段包括：ip分组首部（20byte）、tcp段首部（20byte）、tcp数据块

tcp通过四个值识别：<源ip 源端口 目的ip 目的端口> 所有的tcp连接，不允许四个值完全一摸一样。

# tcp性能考虑

- tcp连接建立握手

如果只是发送小型文件，或者资源变更判断的请求，那么还需要先建立连接（三次握手），那么三次握手的耗时对比于请求而言，就会变得可目测耗时。而且一些小的http报文完全可以放到第三次握手（客户端向服务器发送ack包）时顺带传输。

而长连接，有效地减少了建立tcp造成地影响。

- tcp慢启动拥塞控制

tcp慢启动：为了防止因特网上新建立的连接，突然传输大量分组导致整个网络负载高。简单说：发送端一开始只能发送一个分组，成功被接收后才能发送更多。该新连接慢慢提高传输速率。因此新连接传输速度会比已经交换过一定量数据的连接慢。而长连接，能使得传输速率比新连接快。

- 数据聚集的nagle算法

tcp有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入到tcp栈中——如果每次传入的数据量过小，但是tcp包本身还有自己的标记和首部（40个字节），网络频繁传输这些小分组会导致网络性能变差。

nagle算法会将大量的tcp数据绑定在一起，以提高网络效率，但是小的http报文无法填满一个分组，可能会因为等待那些永远不会到来的额外数据产生延时。其次，nagle算法和延迟算法有冲突。

延迟算法导致接收端的确认分组延迟100-200ms，发送端收到确认分组后，又因nagle算法，导致发送分组延时。

两个结合，导致整个传输速率慢。

一般通过设置 TCP_NODELAY，禁用nagle算法，不过要确保向tcp写入大块的数据。

- 捎带确认的tcp延迟确认算法

因特网无法确保可靠的分组传输，因此要通过tcp自生确认机制。每个接收者收到完好的分组时，会向发送着回送小的确认分组。如果发送者在指定时间内没有收到，那么回重发。而tcp的延迟确认捎带确认算法，会将输出数据分组进行缓存，以求能找到可以捎带确认分组的输出分组，规定时间内没有，才单独发送确认分组。

但由于http双峰特征，偏偏没有那么多可捎带的分组，因此该算法可以被调整或禁止。以提高传输速率。

- time_wait时延和端口耗尽

连接发起端，连接断开后，端口会处于time_wait状态，同时内存维护一个缓存，记录最近关闭的ip地址和端口。以确保在规定时间（通常2min）内不会被再次使用，因为每个分组在网络的存活时间为1min，如果连接A，存在分组1在网络中传输。这是连接A断开了，分组1还存活。然后突然A又被建立，那么分组1会被新建立的连接A所传输，导致新连接传输旧分组，会导致这个连接数据错乱。

虽然2min的延迟不算什么，但是在并发环境下。百万客户端=》nginx=》服务器。

nginx和服务器建立的tcp连接有限。前面说到tcp连接的唯一性

<源ip 源端口 目的ip 目的端口>，这里只有源端口能变。但是有限（60000个），而且使用后有2min延时60000/120 =500 ，因此平均每秒只支持500个连接。

# http连接处理

## connection

connection 首部字段值为 由逗号分隔的连接标签列表，这些标签指定了相邻连接的选项，而不会传播到其他连接去。

即： 客户端 - 》 代理 -》 服务。  如果客户端的请求 带connection，则该connection的标签只适用于客户端 -》 代理之间，不会传播到其他连接去。

connection首部值可以承载3种不同类型的标签

- 指定了该报文的其他首部字段，这些字段只适用此连接。
- 任意标签值，用于描述此连接的非标准首部字段。
- close，说明操作完成，关闭这条连接。

例子：

- connection:keepalive  ，指定了该报文的首部字段keepalive 只适用此连接。

接收端会解析发送端请求的所有选项，并将其应用。然后将此报文转发给下一跳之前，会删除connection首部和connection中列出的所有首部。

## keep-alive

timeout：keep-alive响应首部发送的，它估计服务器系统将连接保持多久，并不是一个承诺值。

max：keep-alive响应首部发送，它不急服务器还希望为多少个事务保持此连接的活跃状态。

```js
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

以上的响应首部字段，表示服务器最多还会为5个事务保持连接的状态，或者打开状态保持空闲了2分钟，之后会关闭。

在http/1.0中，keep-alive并不是默认值，因此客户端必须发送一个Connection:Keep-Alive来激活keep-alive连接。如果没有发送，则请求后服务器会关闭连接。

如果客户端响应中没有Connection：keep-Alive 响应首部，则服务器发出响应后就会关闭连接。

## 哑代理

无法识别Connection ，只会直接转发。

![image-20210623165310982](D:\note\http权威指南\images\image-20210623165310982.png)

P100

## HTTP/1.1 持久连接

以前版本，keep-alive连接要么是可选，要么是不支持。

而1.1版本，默认是激活的，除非特别指明。要关闭连接，则显示地添加Connection:close首部。

- 发送了Connection：close请求首部，客户端就无法在那条连接上发送更多请求。
- 只有连接上地报文都有正确地、自定义报文长度时（实体主体长度和Content-Length一致或分块传输编码方式），连接才能保持持久。

具体看：

http://www.ruanyifeng.com/blog/2016/08/http.html

https://imququ.com/post/transfer-encoding-header-in-http.html