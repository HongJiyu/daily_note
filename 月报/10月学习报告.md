# Libuv事件循环源码浅析

## 整体介绍

来自[nodejs官网介绍](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)

下面的图表展示了事件循环操作顺序的简化概览。

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

- **timers**: this phase executes callbacks scheduled by `setTimeout()` and `setInterval()`.
- **pending callbacks**: executes I/O callbacks deferred to the next loop iteration.
- **idle, prepare**: only used internally.
- **poll**: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and `setImmediate()`); node will block here when appropriate.
- **check**: `setImmediate()` callbacks are invoked here.
- **close callbacks**: some close callbacks, e.g. `socket.on('close', ...)`.

## 主函数

代码来源：https://github.com/libuv/libuv

```js
int uv_run(uv_loop_t* loop, uv_run_mode mode) {
  int timeout;
  int r;
  int ran_pending;
  // 判断是否有活跃handle，request，或者需要关闭的handle
  r = uv__loop_alive(loop);
  if (!r)
      // 更新当前时间
    uv__update_time(loop);
  while (r != 0 && loop->stop_flag == 0) {
    uv__update_time(loop);
      //处理timer阶段
    uv__run_timers(loop);
      //处理pending阶段
    ran_pending = uv__run_pending(loop);
      //处理idle阶段
    uv__run_idle(loop);
      //处理prepare阶段
    uv__run_prepare(loop);
    timeout = 0;
    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
        //计算出poll阶段阻塞时间。
      timeout = uv_backend_timeout(loop);
    // 处理poll阶段
    uv__io_poll(loop, timeout);
    // 处理idle阶段
    uv__metrics_update_idle_time(loop);
    // 处理check阶段
    uv__run_check(loop);
    // 处理close阶段
    uv__run_closing_handles(loop);
    if (mode == UV_RUN_ONCE) {
      uv__update_time(loop);
      uv__run_timers(loop);
    }
    r = uv__loop_alive(loop);
    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)
      break;
  }

  if (loop->stop_flag != 0)
    loop->stop_flag = 0;
  return r;
}
```

## timer阶段（uv__run_timers）

使用到了数据结构：堆

```js
void uv__run_timers(uv_loop_t* loop) {
  struct heap_node* heap_node;
  uv_timer_t* handle;

  for (;;) {
    heap_node = heap_min(timer_heap(loop));
    if (heap_node == NULL)
      break;

    handle = container_of(heap_node, uv_timer_t, heap_node);
    if (handle->timeout > loop->time)
      break;

    uv_timer_stop(handle);
    uv_timer_again(handle);
    handle->timer_cb(handle);
  }
}
```

 简析： 

1. 通过timer_heap获取到这个事件循环中存放定时器的堆，
2. 通过heap_min函数找到最小堆，即堆顶。
3. 通过container_of 找到这个堆对应的handle。
4. 停止这个handle，判断这个handle是否需要重新启用（setInterval类型的定时器）
5. 执行handle回调（定时器回调）。

## pending阶段（uv__run_pending）

使用到的数据结构 双向链接的队列

```js
static int uv__run_pending(uv_loop_t* loop) {
  QUEUE* q;
  QUEUE pq;
  uv__io_t* w;

  if (QUEUE_EMPTY(&loop->pending_queue))
    return 0;

  QUEUE_MOVE(&loop->pending_queue, &pq);

  while (!QUEUE_EMPTY(&pq)) {
    q = QUEUE_HEAD(&pq);
    QUEUE_REMOVE(q);
    QUEUE_INIT(q);
    w = QUEUE_DATA(q, uv__io_t, pending_queue);
    w->cb(loop, w, POLLOUT);
  }

  return 1;
}
```

简析：

1. 拿到这个事件循环的pending队列。
2. 将这个队列除头节点全部迁移到新节点`pq` 上。防止当前新产生的事件也在该阶段被执行回调了。
3. 遍历、执行回调

## 其他

未读。

# nginx初步学习

## 基本指令

### 启动

1. 直接执行nginx二进制程序

读取默认路径下的配置文件： `/usr/local/nginx/conf/nginx.conf`

没有显示指定时，将打开configure命令执行时的`--config-path=Path ` 指定的`nginx.config`文件

2. 指定配置文件的启动方式

`nginx -c nginx.conf`

### 配置检查

`nginx -t -c nginx.conf`

### 强制关闭

`nginx -s stop`

### 优雅关闭

`nginx -s quit`

### 配置重启

`nginx -s reload`