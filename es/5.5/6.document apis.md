# reading and writing documents

本节主要介绍es的复制模型，并讨论在写和读的各种交互的操作时，它有怎样的影响。

## basic write model

略

# index api

在指定的索引下增加或者更新json格式的文档。

```json
PUT twitter/tweet/1
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```

```json
{
    "_shards" : {
        "total" : 2,
        "failed" : 0,
        "successful" : 1
    },
    "_index" : "twitter",
    "_type" : "tweet",
    "_id" : "1",
    "_version" : 1,
    "created" : true,
    "result" : created
}
```

total：录入该文档，涉及到的分片数量（包括主分片和副本分片）。

successful：成功录入的分片数量。

failed：失败的分片数量。

**注意：**如果只开启一个节点，且只有一个节点，并且索引配置如下：

```json
{
    "settings" : {
        "index" : {
            "number_of_shards" : 3, 
            "number_of_replicas" : 4
        }
    }
}
//录入一个文档后，返回如下：
{
    "_shards" : {
        "total" : 5,
        "failed" : 0,
        "successful" : 1
    }
}
```

已知只有一个节点，所以该节点都是主分片，所有的副本分片都没有启动。

total：是基于number_of_replicas，因此是4+1（4个副本+1个主分片）

failed：没有失败，主分片成功了，而没有副本分片，因此不算入失败。

successful：只有主分片并且成功。

## automatic index creation

如果之前没有创建索引，那么以上操作会自动创建索引。

如果之前没有创建映射，那么以上操作会自动创建映射，同时映射是非常灵活无结构的。会根据新的字段或者对象自动创建映射。

禁止自动创建：在所有的节点的配置文件中加上：

`action.auto_create_index`

`index.mapper.dynamic`

同时索引创建支持黑/白名单。

`action.auto_create_index`： `+aaa*,-bbb*,+ccc*,-*`

## versioning

## version types

## operation type

`PUT twitter/tweet/1` 默认是覆盖。

可以通过参数`op_type`，只有在不存在时才创建，存在时失败。

```json
PUT twitter/tweet/1?op_type=create
PUT twitter/tweet/1/_create
```

## automatic id generation

如果没有指定id，id会自动生成。

```json
POST twitter/tweet/
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```

## routing

```json
POST twitter/tweet?routing=kimchy
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
```

默认一个文档的录入，会根据id来计算hash值，然后再确定会被放入到指定的分片上。如果指定`routing`，那么会根据这个`routing`值来替换id值计算来存放。

routing也可以在映射中指定。

作用：如果一个查询

```json
GET /testindex/_doc/_search
{
    "query":{
        "match":{
            "content":"get a dog"
        }
    }
}
```

该查询会将请求广播到所有分片，然后各自查完再返回协调节点，整合后再返回给用户。

如果一开始在录入时就指定了这类文档的位置，

`POST /testindex/_doc?routing=xxxx`

那么在查询时这样指定：

`GET /testindex/_doc/_search?routing=xxxx`

那么就不需要广播到所有分片，而是直接在计算得到的指定分片下去查找。可以提高效率，减少性能开销。

缺点：文档分布不均匀。

## parents & children

```json
PUT blogs
{
  "mappings": {
    "tag_parent": {}, //父类型
    "blog_tag": {     // 子类型
      "_parent": {    //在子类型指定其父
        "type": "tag_parent"
      },
       "properties":{}
    }
  }
}

PUT blogs/blog_tag/1122?parent=1111
{
    "tag" : "something"
}
```

当录入子文档时，其routing值自动被设置为与其父一致。除非有明确指定了routing值。

## distributed

录入操作基于路由被直接对准主分片并且在拥有该主分片的节点上执行。等到主分片完成操作后，如果需要，他会更新到副本分片上。

## wait for active shards

为了系统写的弹性，可以配置一个参数。使得写操作只有指定数量的分片是活跃的，才会去执行。默认是主分片活跃即可。

在索引上配置：`index.write.wait_for_active_shards`。

在请求url上配：`wait_for_active_shards`

其值为all 或者 1<=x<number_of_replicas+1 。

会在执行写请求前，去判断当前索引的活跃分片是否达到数量了。如果没有，则会进行等待直到超时。

因为检查是在写操作之前。如果检查时活跃分片是符合，但是执行时有活跃分片有问题。那么也会导致写的分片数量与预期不符合。

## refresh

## noop updates

## timeout

