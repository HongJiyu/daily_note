search apis 基本都是支持多索引多类型的，除了[explain api](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/search-explain.html)

## routing

看document apis的routing，有写。

## stats groups

不懂

## global search timeout

在search body 中，可以指定timeout。有一个全局的timeout`search.default_search_timeout`，可以通过 [*Cluster Update Settings*](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/cluster-update-settings.html) endpoints去配置。设置为-1，则代表不会超时。

## search cancellation

可以使用 [task cancellation](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/tasks.html#task-cancellation) 机制去取消查询。不懂。

# search

searh api 允许执行搜索查询并且返回匹配到的结果。查询支持url参数或者是请求体。

## multi-index，multi-type

多索引支持第5节的内容。

```json
GET /twitter/_search?q=user:kimchy
GET /twitter/tweet,user/_search?q=user:kimchy
GET /kimchy,elasticsearch/tweet/_search?q=tag:wow
GET /_all/tweet/_search?q=tag:wow
GET /_search?q=tag:wow
```

默认下，es不会基于请求命中的分片数来拒绝任何搜索请求。es会在协调节点优化搜索执行，但大量的分片数回对cpu和内存有较大的影响。通常最好的主意是组织数据使得更少的大分片。或者可以配置软限制，更新集群配置`action.search.shard_count.limit`，去拒绝搜索时命中过多的分片。

# url search

一个搜索请求可以被单纯地使用url并提供请求参数来执行。当使用这种模式时，不需要所有的搜索选项都暴露，就可以很便利地进行测试。

```json
GET twitter/tweet/_search?q=user:kimchy
```

## parameters

- q：等同于[query_string](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-query-string-query.html)

- df：当在查询中没有字段前缀时，它被使用。
- analyzer：解析器
- analyze_wildcard：通配或前缀查询是否需要被解析。默认是false。
- batched_reduce_size：此参数用来限制协调节点（也就是接受请求的节点）一次（批）处理的分片数量，如果命中的分片数量大于此参数值，则会分批执行，默认值为512。如果请求中潜在的分片数量很大，则应将此值用作保护机制，以减少每个搜索请求的内存开销。
- default_operator：默认操作：and、or 。默认是or。即match:"fool fox"。被拆分为fool和fox，这两者的关系是or。即满足一个即可。
- lenient：将会使得基于格式错误被忽略（提供一个text给数值字段），默认是false。

- explain：对于每次命中，包含这次命中的分数是如何计算的。
- _source：如果为false，那么该字段不会被返回。或者可以使用`source_include`和`source_exclude`来获取文档的部分。
- stored_fields：指定返回存储字段。那么不会返回source字段。
- sort：可以使用fieldName或者 fieldName:asc/fieldName:desc的格式。fieldName可以是文档的确切字段，或者是_score以此来表明基于分数排序
- track_scores：当排序时，设置为true，为了跟踪分数并将它们作为命中的一部分返回。
- timeout：默认是没有超时，限制了搜索请求在指定的时间，并在过期时使用累积到该时间点的命中量。
- terminate_after：每个分片搜集的最大文档数量，达到该值则查询执行将被提前终止。返回结果将会有`terminated_early`去指示该查询被提前终止了。默认是没有该配置。
- from
- size
- search_type：默认是`query_then_fetch`，具体看本节的search type。

# request body search

搜索请求可以使用搜索dsl来执行同样包括查询dsl。

```json
GET /twitter/tweet/_search
{
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## parameters

- timeout：默认是没有超时，限制了搜索请求在指定的时间，并在过期时使用累积到该时间点的命中量。
- from
- size
- search_type
- request_cache：通过true、false，来控制开启或者禁用 请求中size为0的搜索结果。例如：聚合和建议。 See [Shard request cache](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/shard-request-cache.html)
- terminate_after：每个分片搜集的最大文档数量，达到该值则查询执行将被提前终止。返回结果将会有`terminated_early`去指示该查询被提前终止了。默认是没有该配置。
- batched_reduce_size：此参数用来限制协调节点（也就是接受请求的节点）一次（批）处理的分片数量，如果命中的分片数量大于此参数值，则会分批执行，默认值为512。如果请求中潜在的分片数量很大，则应将此值用作保护机制，以减少每个搜索请求的内存开销。

上述参数中，`search_type`和`request_cache`必须作为查询字符串参数传递。其余的应该放在请求体中。

get和post都可以执行带有请求体的搜索，因为不是所有的客户端都支持get。

## fast check for any matching docs

快速检查我们所想要检索的内容是否存在

```json
GET /_search?q=message:elasticsearch&size=0&terminate_after=1
```

size为0，表明不在乎搜索具体结果。

terminate_after：找到有一个匹配的文档则立即停止。因此叫做fast check。

```json
{
  "took": 3,
  "timed_out": false,
  "terminated_early": true,
  "_shards": {
    "total": 1,
    "successful": 1,
    "failed": 0
  },
  "hits": {
    "total": 1,
    "max_score": 0.0,
    "hits": []
  }
}
```

## query

在请求体的query元素允许使用query dsl定义查询。

## from/size

 注意：form+size 不能超过`index.max_result_window`的索引配置，默认是10000，更高效的深度滚动则看： [Scroll](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/search-request-scroll.html) or [Search After](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/search-request-search-after.html) API