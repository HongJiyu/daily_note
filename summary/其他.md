# grafana

监控平台（mysql）

# 单点登录

https://blog.csdn.net/qq_33472765/article/details/81489158

- 普通登录流程

登录系统（s1）、业务系统（s2）。

s2判断session，无则拼接访问s1的地址，并带上s2回调地址。访问s1，在s1点击登录通过回调地址访问回s2并带上code，code是一个凭证。都正常则s2再调用s1，传递code获取登录信息（s1给s2传应用信息，s2返回用户信息）。

s1存放全局会话，s2存放局部会话。

s1 和 s2 的每次交互都要验证对方的ip。

- 单点登录

登录系统（s1）、业务系统（s2）、业务系统（s3）。

s2访问s1，登录后，s3直接就能登录。

因为s2在访问s1页面，点击登录时，s1已经创建了cookie。然后s3登录，再次访问s1，s1拿到cookie，判断登录信息，登录过，直接重定向s3的回调接口并带上登录信息。因此s3是免登录的。

原理：整个场景下浏览器存储了s1的cookie，在s2登录时跳转到s1页面时，在s1页面点击登录时设置的。之后任何业务系统登录，跳转到s1，都会有这个cookie。s1的cookie是单点登录的关键。



# 大文件上传下载

## 上传

大文件上传的原因：超时、失败后得重新开始。速度并不是重要的影响因素。

- 前端将文件分片：基于blob对象的slice方法，file是继承于blob的，file.splice(0,size);，将所有的片放到arr中。
- 前端使用md5-file包，计算文件完整的md5值。
- 前端上传前先调用后端校验的接口，用于验证文件是否上传成功（是否已经存在文件）是则返回。否则查看分片目录下是否存在分片，看看分片上传了多少，所有分片信息返回给前端。
- 如果文件已经存在则就算实现秒传（进度条直接100），如果文件不存在，但是存在分片信息（修改进度条），则验证并将其他未上传的分片上传。前端上传后，通知后端进行文件合并。
- 后端通过fs的append，合并所有分片文件，并计算allmd5，生成内容为allmd5的文件。根据前端计算的allmd5和后端的allmd5进行对比。



todo：后端怎么计算md5。要很久？fork子进程？

md5-file提供了异步的方法。3.5g用5s，可以考虑fork子进程实现。该插件使用的是流和pipe，并不需要占用太多内存，耗费更多的是cpu。

todo：获取合并的进度，怎么判断。

访问该分片的目录，获取当前剩余的分片数量last，并取最后一个分片的名字（hash-num），即可知道所有的分片数量all。则进度是  `(all-last)/all`

优化的点：也可以计算抽样md5值：使用每个片的前中后三个字节组合成的数据进行md5。因为大文件（G级别）的文件计算md5很慢。（1个g，抽样要800ms，完整的md5要20s）

## 下载

- 原理

https://blog.csdn.net/thanklife/article/details/77962767

https://www.cnblogs.com/zxtceq/p/7146760.html

客户端发送range头部，标明需要文件的范围

```js
    表示头500个字节：Range: bytes=0-499
    表示第二个500字节：Range: bytes=500-999
    表示最后500个字节：Range: bytes=-500
    表示500字节以后的范围：Range: bytes=500-
    第一个和最后一个字节：Range: bytes=0-0,-1
    同时指定几个范围：Range: bytes=500-600,601-999
```

响应content-range，

```js
HTTP/1.1 206 OK
表示处理请求成功，响应报文还有这一行
Content-Range: bytes 200-299/403
斜杠后面的403表示文件的大小，通常Content-Range的用法为：
     . The first 500 bytes:
     Content-Range: bytes 0-499/1234

     . The second 500 bytes:
     Content-Range: bytes 500-999/1234

     . All except for the first 500 bytes:
     Content-Range: bytes 500-1233/1234

     . The last 500 bytes:
     Content-Range: bytes 734-1233/1234
```

- 实现

koa-range 包，将其放到路由上，自动帮我们实现。自动帮我们处理请求的range，并处理返回头content-range

注意看issue，koa-range存在问题。

![image-20220209222612016](images\image-20220209222612016.png)

简单说就是：koa-range作为中间件，需要业务方提供整个文件流，然后再根据请求头的range，对文件流进行切分。如果是续传的情况下，那每次都需要业务方读取整个文件流，速率会非常慢。

解决：修改koa-range的包，使其能够接受path，去根据路径及range头信息读取指定文件的内容。而业务方只需要返回文件路径即可。

[@masx200/koa-range ](https://www.npmjs.com/package/@masx200/koa-range) 使用此包即可。

