ts 强在类型，函数返回值类型、函数参数类型等，使得开发阶段便对变量类型做好限制。便于在开发阶段就发现问题，而不是等到运行时才发现。

ts代码，需要编译成js脚本才能执行。

自动赋予变量指定类型，然后无法赋予其他类型的值。`let param = false; param ='报错';`

# 类型

boolean、number、string 、 number[]、null、undefined、object、symbol

元组、枚举、any、void、never、unknow

## string

字符串字面量

`let str: 'Lison'  str = 'haha'`   当一个变量指定为字符串字面量时，无法赋予其他值。

## null 、undefined

既是类型又是值

`let u: undefined = undefined; let n: null = null;`

## object

`let obj: object  obj = { name: 'Lison' }  console.log(obj.name) `  报错，因为需要通过接口实现。

## 元组

数组的扩展，限制 各个位置的元素类型及总元素数量。

等同于

```typescript
interface Tuple extends Array<number | string> {
  0: string;
  1: number;
  length: 2;
}
let arr:Tuple = ["11",1];
```

## 枚举

本小节我们学习了两种基本的枚举：数字枚举和字符串枚举，它俩的最主要的区别就是枚举成员值的类型了，数字枚举成员的值必须都是数值类型，而字符串枚举成员的值必须都是字符串。枚举还有一个概念叫反向映射，就是当我们定义了枚举值后，不仅定义了字段到值的映射，同时编译器根据反向映射定义了值到字段的映射。我们还学习了数字枚举和字符串枚举的杂交体——异构枚举，但是很少用，原因也解释过了；枚举值和枚举成员在作为值使用的同时，还可以作为类型使用，但是有三个条件，可以回顾下；最后我们还学习了枚举值在编译后是一个对象，可以在运行时使用，如果我们在运行时用不到，可以在定义枚举时在前面加上`const`来选择不生成对象，而是直接将值替换到响应位置。

默认从0开始。

```typescript
enum Roles {
  SUPER_ADMIN,
  ADMIN,
  USER
}

```

- 枚举成员类型

```typescript
enum Animal {
  Dog = 1,
  Cat = 2
}
interface Dog {
  type: Animal.Dog; // 这里使用Animal.Dog作为类型，指定接口Dog的必须有一个type字段，且类型为Animal.Dog
}
```

- 联合枚举类型

```typescript
enum Status {
  Off,
  On
}
interface Light {
  status: Status;
}
```

- 枚举 其实被编译成一个对象，因此可以把它当作对象使用。

- 定义枚举的语句之前加上`const`关键字，这样编译后的代码不会创建这个对象，只是会从枚举里拿到相应的值进行替换。

```typescript
const enum Animal {
  Dog,
  Cat
}
const animal = Animal.Dog;
// 编译后：
var animal = 0; 
```

```typescript
enum Status {
  Off,
  On
}
const status = Status.On;
// 编译后
var Status;
(function(Status) {
  Status[(Status["Off"] = 0)] = "Off";
  Status[(Status["On"] = 1)] = "On";
})(Status || (Status = {}));
```

## any

任意类型，就好比没有使用ts。

你可以随意对它进行属性方法的访问，不管有的还是没有的，可以把它当做任意类型的值来使用。

```typescript
let value: any
console.log(value.name)
console.log(value.toFixed())
console.log(value.length)
```

开发时不会报错，但是执行时报错。

## void

void 和 any 相反，any 是表示任意类型，而 void 是表示没有任意类型。

```typescript
const consoleText = (text: string): void => {
  console.log(text);
};
```

函数执行完返回。

## never

根本不会有返回值的函数，它和之前讲 void 类型时不同，`consoleText`函数没有返回值，是我们在定义函数的时候没有给它返回值，而`infiniteFunc`是死循环，或者抛出异常是根本不会返回值的，所以它们二者还是有区别的。

```typescript
const errorFunc = (message: string): never => {
  throw new Error(message);
};

const infiniteFunc = (): never => {
  while (true) {}
};
```

不可能走到返回的操作，在中途抛出一唱歌或死循环。

## unknow

如果没有通过基于控制流的类型断言来缩小范围的话，是不能对它进行任何操作的。 待扩展

# 类型断言

告诉编译器，我们人工判断这个变量就是这个类型，不需要编译器去自动判断。

```typescript
变量 as 类型
```

```typescript
const getLength = (target: string | number): number => {
  if (target.length) { // error 
    return target.length; // error 
  } else {
    return target.toString().length;
  }
};
```

解决：

```typescript
const getStrLength = (target: string | number): number => {
  if ((<string>target).length) { // 这种形式在JSX代码中不可以使用，而且也是TSLint不建议的写法
    return (target as string).length; // 这种形式是没有任何问题的写法，所以建议大家始终使用这种形式
  } else {
    return target.toString().length;
  }
};
```

# 接口定义

定义参数的具体类型后，少传多传都会报错。

```typescript
interface Vegetables {
    color: string;
    type: string;
  }

const getVegetables = ({ color, type }:Vegetables):string => {
    return `A ${color ? color + " " : ""}${type}`;
  };

getVegetables({
    color:"",
    type:""
})
```

少传，设置属性为可选，没传的赋值为undefined

```typescript
interface Vegetables {
  color?: string;
  type: string;
}
```

多传，只能绕过检查。

- 使用类型断言，不让编译器检查，而由我们自己定义

```typescript
getVegetables({
  type: "tomato",
  size: 12,
  price: 1.2
} as Vegetables);
```

- 索引签名

```typescript
interface Vegetables {
  color: string;
  type: string;
  [prop: string]: any;
}
```

## 只读

变量只读用const，属性只读用readonly

```typescript
const NAME: string = "Lison";
NAME = "Haha";
```

```typescript
interface Info {
  readonly name: string;
}
const info: Info = {
  name: "Lison"
};
info["name"] = "Haha";
```

## 函数类型（接口上定义）

接口可以描述普通对象，还可以描述函数类型，我们先看写法：

```typescript
interface Counter {
  (): void; // 这里定义Counter这个结构必须包含一个函数，函数的要求是无参数，返回值为void，即无返回值
  count: number; // 而且这个结构还必须包含一个名为count、值的类型为number类型的属性
}
const getCounter = (): Counter => { // 这里定义一个函数用来返回这个计数器
  const c = () => { // 定义一个函数，逻辑和前面例子的一样
    c.count++;
  };
  c.count = 0; // 再给这个函数添加一个count属性初始值为0
  return c; // 最后返回这个函数对象
};
const counter: Counter = getCounter(); // 通过getCounter函数得到这个计数器
counter();
console.log(counter.count); // 1
```

## 索引类型（key类型）

可以同时给索引和值都设置类型，索引类型设置为string，而传入的是数值，也不会报错。因为 JS 在访问属性值的时候，如果属性名是数值类型，会先将数值类型转为字符串，然后再去访问。

```typescript
interface RoleDic {
  [id: string]: string;
}
const role1: RoleDic = {
  0: "super_admin",
  1: "admin"
};
const role3: RoleDic = ["super_admin", "admin"];
```

## 继承

一个接口可以被多个接口继承，同样，一个接口也可以继承多个接口，多个接口用逗号隔开。

```typescript
interface Vegetables {
  color: string;
}
interface Tomato extends Vegetables {
  radius: number;
}
interface Carrot extends Vegetables {
  length: number;
}
const tomato: Tomato = {
  radius: 1.2 // error  Property 'color' is missing in type '{ radius: number; }'
};
const carrot: Carrot = {
  color: "orange",
  length: 20
};
```

# 函数和函数参数

如果省略参数的类型，TypeScript 会默认这个参数是 any 类型；如果省略返回值的类型，如果函数无返回值，那么 TypeScript 会默认函数返回值是 void 类型；如果函数有返回值，那么 TypeScript 会根据我们定义的逻辑推断出返回类型。

```typescript
let add: (x: number, y: number) => number; //函数类型
add = (arg1: number, arg2: number): number => arg1 + arg2; //实际函数
add = (arg1: string, arg2: string): string => arg1 + arg2; //实际函数，报错error
```

## 接口上定义函数类型

```typescript
interface Add {  // 函数类型
  (x: number, y: number): number;
}
let add: Add = (arg1: string, arg2: string): string => arg1 + arg2; 
```

## 类型别名

```typescript
type Add = (x: number, y: number) => number;  //函数类型
```

使用`type`关键字可以为原始值、联合类型、元组以及任何我们定义的类型起一个别名。

## 参数

可选参数：

```typescript
type Add = (x?: number, y: number) => number; // error 必选参数不能位于可选参数后。
```

```typescript
type Add = (x: number, y?: number) => number; 
```

默认参数：

```typescript
const add = (x: number, y: number = 2) => {
  return x + y;
};
```

多参数：

```typescript
const handleData = (arg1: number, ...args: number[]) => {
  //
};
handleData(1, "a");
```

## 重载

JavaScript 作为一个动态语言是没有函数重载的，只能我们自己在函数体内通过判断参数的个数、类型来指定不同的处理逻辑。

在 TypeScript 中有函数重载的概念，但并不是定义几个同名实体函数，然后根据不同的参数个数或类型来自动调用相应的函数。

```typescript
function handleData(x: string): string[]; // 这个是重载的一部分，指定当参数类型为string时，返回值为string类型的元素构成的数组
function handleData(x: number): string; // 这个也是重载的一部分，指定当参数类型为number时，返回值类型为string
function handleData(x: any): any { // 这个就是重载的内容了，他是实体函数，不算做重载的部分
  if (typeof x === "string") {
    return x.split("");
  } else {
    return x
      .toString()
      .split("")
      .join("_");
  }
}
handleData("abc").join("_");
handleData(123).join("_"); // error 类型"string"上不存在属性"join"
handleData(false); // error 类型"boolean"的参数不能赋给类型"number"的参数。
```

首先我们使用`function`关键字定义了两个同名的函数，但不同的是，函数没有实际的函数体逻辑，而是只定义函数名、参数及参数类型以及函数的返回值类型；而第三个使用`function`定义的同名函数，是一个完整的实体函数，包含函数名、参数及参数类型、返回值类型和函数体；这三个定义组成了一个函数——完整的带有类型定义的函数，前两个`function`定义的就称为*函数重载*，而第三个`function`并不算重载；

最后还有一点要注意的是，这里重载只能用 function 来定义，不能使用接口、类型别名等。

# 泛型

可用于解决any类出现的问题。

泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

```typescript
// 不使用泛型
const getArray = (value: any, times: number = 5): any[] => {
  return new Array(times).fill(value);
};
getArray(2, 3).forEach(item => {
  console.log(item.length);  //执行时报错
});

// 使用泛型
const getArray = <T>(value: T, times: number = 5): T[] => {
  return new Array(times).fill(value);
};
getArray<number>(2, 3).forEach(item => {
  console.log(item.length); // 编写时报错
});
```

## 泛型变量

你必须在处理类型涉及到泛型的数据的时候，把这个数据当做任意类型来处理。这就意味着不是所有类型都能做的操作不能做，不是所有类型都能调用的方法不能调用。

```typescript
const getLength = <T>(param: T): number => {
  return param.length; // error 类型“T”上不存在属性“length”
};
```

如果 param 的类型为数组 Array 或字符串 string 类型是没问题的，它们有 length 属性。但是如果此时传入的 param 是数值 number 类型，那这里就会有问题了。

多个泛型：

```typescript
const getArray = <T, U>(param1: T, param2: U, times: number): [T, U][] => {
  return new Array(times).fill([param1, param2]);
};
getArray(1, "a", 3).forEach(item => {
  console.log(item[0].length); // error 类型“number”上不存在属性“length”
  console.log(item[1].toFixed(2)); // error 属性“toFixed”在类型“string”上不存在
});
```

## 泛型函数

```typescript
// ex1: 简单定义
const getArray: <T>(arg: T, times: number) => T[] = (arg, times) => {
  return new Array(times).fill(arg);
};
// ex2: 使用类型别名
type GetArray = <T>(arg: T, times: number) => T[];
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};
```

当然了，我们也可以使用接口的形式来定义泛型函数类型：

```typescript
interface GetArray {
  <T>(arg: T, times: number): T[];
}
const getArray: GetArray = <T>(arg: T, times: number): T[] => {
  return new Array(times).fill(arg);
};
```

泛型提升到外面

```typescript
interface GetArray<T> {
    (arg: T, times: number): T[];
    tag: T;
  }
  const getArray: GetArray<number> = <T>(arg: T, times: number): T[] => {
    return new Array(times).fill(arg);
  };
  getArray.tag = 1;
  getArray(2, 1);
```

## 泛型约束

如果 param 的类型为数组 Array 或字符串 string 类型是没问题的，它们有 length 属性。但是如果此时传入的 param 是数值 number 类型，那这里就会有问题了。

```typescript
const getLength = <T>(param: T): number => {
  return param.length;// error 类型“T”上不存在属性“length”
};
```

因此对泛型进行了约束，保证泛型是有length属性。

```typescript
interface ValueWithLength {
  length: number;
}
const getLength = <T extends ValueWithLength>(param: T): number => {
  return param.length;
};
```

## 泛型约束使用类型参数

当我们定义一个对象，想要对只能访问对象上存在的属性做要求时，该怎么办？先来看下这个需求是什么样子：

```typescript
const getProps = (object, propName) => {
  return object[propName];
};
const obj = { a: "aa", b: "bb" };
getProps(obj, "c"); // undefined
```

当我们访问这个对象的’c’属性时，这个属性是没有的。这里我们需要用到索引类型`keyof`结合泛型来实现对这个问题的检查。索引类型在高级类型一节会详细讲解，这里你只要知道这个例子就可以了：

```typescript
const getProp = <T, K extends keyof T>(object: T, propName: K) => {
  return object[propName];
};
const obj = { a: "aa", b: "bb" };
getProp(obj, "c"); // 类型“"c"”的参数不能赋给类型“"a" | "b"”的参数
```

这里我们使用让`K`来继承索引类型`keyof T`，你可以理解为`keyof T`相当于一个由泛型变量T的属性名构成的联合类型，在这里 K 就被约束为了只能是"a"或"b"，所以当我们传入字符串"c"想要获取对象*obj*的属性"c"时就会报错。

# 类

## 区别

类、抽象类、接口

只有接口与接口之间通过implement，其他类型都用extends。

接口，任何类实现接口，都需要对所有属性和函数进行实现。

抽象类，通过abstract修饰属性和函数，来让实现类针对性地实现。

至于构造函数，子类不写，就默认用父类的。

## 修饰符

- public：公有属性方法修饰符，这是默认修饰符；
- private：私有修饰符，它修饰的属性在类的定义外面无法访问，子类也无法访问；
- protected：和private相似，区别在于他修饰的成员在继承该类的子类中可以访问。

还有一个readonly修饰符，他在讲前面知识的时候就遇到过，只读修饰符。

`protected`还能用来修饰 constructor 构造函数，加了`protected`修饰符之后，这个类就不能再用来创建实例，只能被子类继承。

## 参数属性

之前的例子中，我们都是在类的定义的顶部初始化实例属性，在 constructor 里接收参数然后对实力属性进行赋值，我们可以使用*参数属性*来简化这个过程。参数属性简单来说就是在 constructor 构造函数的参数前面加上访问限定符，也就是前面讲的 public、private、protected 和 readonly 中的任意一个，我们来看例子：

```typescript
class A {
  constructor(name: string) {}
}
const a = new A("aaa");
console.log(a.name); // error 类型“A”上不存在属性“name”

class B {
  constructor(public name: string) {}
}
const b = new B("bbb");
console.log(b.name); // "bbb"
```

## 静态属性

static

## 可选类属性

```typescript
class Info {
  name: string;
  age?: number;
  constructor(name: string, age?: number, public sex?: string) {
    this.name = name;
    this.age = age;
  }
}
```

## 存取器

这个也就 ES6 标准中的存值函数和取值函数，也就是在设置属性值的时候调用的函数，和在访问属性值的时候调用的函数，用法和写法和 ES6 的没有区别：

```typescript
class UserInfo {
  private _fullName: string;
  constructor() {}
  get fullName() {
    return this._fullName;
  }
  set fullName(value) {
    console.log(`setter: ${value}`);
    this._fullName = value;
  }
}
const user = new UserInfo();
user.fullName = "Lison Li"; // "setter: Lison Li"
console.log(user.fullName); // "Lison Li"
```

## 抽象类

```typescript
abstract class People {
  constructor(public name: string) {}
  abstract printName(): void;
}
class Man extends People {
  constructor(name: string) {
    super(name);
    this.name = name;
  }
  printName() {
    console.log(this.name);
  }
}
const m = new Man(); // error 应有 1 个参数，但获得 0 个
const man = new Man("lison");
man.printName(); // 'lison'
const p = new People("lison"); // error 无法创建抽象类的实例
```

## 接口继承类

接口可以继承一个类，当接口继承了该类后，会继承类的成员，但是不包括其实现，也就是只继承成员以及成员类型。接口还会继承类的`private`和`protected`修饰的成员，当接口继承的这个类中包含这两个修饰符修饰的成员时，这个接口只可被这个类或他的子类实现。

```typescript
class A {
  protected name: string;
}
interface I extends A {}
class B implements I {} // error Property 'name' is missing in type 'B' but required in type 'I'
class C implements I {
  // error 属性“name”受保护，但类型“C”并不是从“A”派生的类
  name: string;
}
class D extends A implements I {
  getName() {
    return this.name;
  }
}
```

## 在泛型中使用类类型

这里我们先来看个例子：

```typescript
const create = <T>(c: { new (): T }): T => {
  return new c();
};
class Info {
  age: number;
}
create(Info).age;
create(Info).name; // error 类型“Info”上不存在属性“name”
```

在这个例子里，我们创建了一个一个 create 函数，传入的参数是一个类，返回的是一个类创建的实例，这里有几个点要讲：

- 参数 c 的类型定义中，new()代表调用类的构造函数，他的类型也就是类创建实例后的实例的类型。
- return new c()这里使用传进来的类 c 创建一个实例并返回，返回的实例类型也就是函数的返回值类型。

所以通过这个定义，TS 就知道，调用 create 函数，传入的和返回的值都应该是同一个类类型。

# 类型推导

自动赋予变量指定类型，然后无法赋予其他类型的值。`let param = false; param ='报错';`

因为ts会自动根据等式右边推导出变量的类型。

```typescript
let arr = [1, "a"];
arr = ["b", 2, false];// error 不能将类型“false”分配给类型“string | number”
```

```typescript
let value = Math.random() * 10 > 5 ? 'abc' : 123
value = false // error 不能将类型“false”分配给类型“string | number”
```

# 类型兼容

略

# 类型保护

当允许某个变量有多个类型时，使用typeof 或者 instance of来判断

## typeof

- 只能使用`=`和`!`两种形式来比较
- type 只能是`number`、`string`、`boolean`和`symbol`四种类型

第一点要求我们必须使用这两种形式来做比较，比如你使用`(typeof item).includes(‘string’)`也能做判断，但是不行的。

第二点要求我们要比较的类型只能是这四种，但是我们知道，在 JS 中，`typeof xxx`的结果还有`object`、`function`和 `undefined` 。但是在 TS 中，只会把对前面四种类型的 typeof 比较识别为类型保护，你可以使用`typeof {} === ‘object’`，但是这里它只是一条普通的 js 语句，不具有类型保护具有的效果。我们可以来看例子：

```typescript
const valueList = [{}, () => {}];
const getRandomValue = () => {
  const number = Math.random() * 10;
  if (number < 5) {
    return valueList[0];
  } else {
    return valueList[1];
  }
};
const res = getRandomValue();
if (typeof res === "object") {
  console.log(res.toString());
} else {
  console.log(ress()); // error 无法调用类型缺少调用签名的表达式。类型“{}”没有兼容的调用签名 todo
}
```

## instance of



# 赋值断言

当我们开启 strictNullChecks 时，有些情况下编译器是无法在我们声明一些变量前知道一个值是否是 null 的，所以我们需要使用类型断言手动指明该值不为 null。

```typescript
function getSplicedStr(num: number | null): string {
  function getRes(prefix: string) { // 这里在函数getSplicedStr里定义一个函数getRes，我们最后调用getSplicedStr返回的值实际是getRes运行后的返回值
    return prefix + num.toFixed().toString(); // 这里使用参数num，num的类型为number或null，在运行前编译器是无法知道在运行时num参数的实际类型的，所以这里会报错，因为num参数可能为null
  }
  num = num || 0.1; // 但是这里进行了赋值，如果num为null则会将0.1赋给num，所以实际调用getRes的时候，getRes里的num拿到的始终不为null
  return getRes("lison");
}
```

这个例子中，因为有嵌套函数，而编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式），所以我们需要使用显式赋值断言，写法就是在不为 null 的值后面加个`!`。来看上面的例子该怎么改：

```typescript
function getSplicedStr(num: number | null): string {
  function getLength(prefix: string) {
    return prefix + num!.toFixed().toString();
  }
  num = num || 0.1;
  return getLength("lison");
}
```

这样编译器就知道了，num 不为 null，即便 getSplicedStr 函数在调用的时候传进来的参数是null，在 getLength函数中的 num 也不会是 null。

# 类型别名和字面量类型

