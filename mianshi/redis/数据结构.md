通过`object encoding xxx` ，查看该键的底层数据结构

# 简单动态字符串

使用SDS来保存字符串，而不用c原生的以空字符结尾的字符数组作为字符串实现。

![image-20220212115332146](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212115332146.png)

len+free+1 就是这个buf[]占用的字节数。这个1是空字符'\0'

- len轻松获取字符串的长度，O（n）
- 封装了自动扩容，不需要自行判断。防止溢出问题
- 解除了字符串长度和底层数组长度关联，进行增加时预分配，由free记录空余的，缩短时使用惰性删除，即不立即缩小数组，而是用free记录。
- 二进制安全：在C语言中的字符串必须以'\0'结尾而且字符串里面不能包含空字符，这样使得c字符串只能保存文本，不能保存图片、视频、压缩文件这样的二进制数据。如果存储图片的二进制，肯定会有结束符 `\0`，此时，图片就不完整，因而，会出现编码的问题。而sds有len，根据len来读取内容，所以是二进制安全

# 链表

当一个列表键包含数量较多的元素，或者列表元素都是较长的字符串，就会使用链表作为列表键的底层实现。

**由链表头和链表节点组成**

## 链表头

![image-20220212135311659](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212135311659.png)

## 链表节点

![image-20220212135235223](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212135235223.png)

## 总结

![image-20220212135407059](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212135407059.png)

双端、无环、带表头表尾指针、长度计数器、多态。

# 字典

**redis数据库**底层使用字典实现，哈希键的底层实现之一

**由字典、哈希表、哈希表节点组成**

## 哈希表

![image-20220212140142444](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212140142444.png)

## 哈希表节点

![image-20220212140214650](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212140214650.png)

## 哈希冲突

冲突则使用链表next指针关联起来

![image-20220212140400005](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212140400005.png)

table 哈希表、size：table的大小、sizemask：size-1、used：已用

## 字典

![image-20220212140424404](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212140424404.png)

作用是存放两个哈希表，和rehash，用于哈希表的负载因子维持在一个合理范围，当保存的键值对数量多或者少，会对哈希表的大小进行合理扩缩容。rehash：对第二个表根据第一个表进行扩缩容后，将第一个哈希表的键值重新hash到第二个哈希表中。

- 扩容，则是已用大小*2 ，再向上取，取到2的幂次值。缩容，则是已用的向上取整，取到2的幂次值。2的幂次是为了计算键的位置（hash与sizemask取余）的优化

## 渐进式rehash

rehash式分多次、渐进式地完成。因为千万，亿级别地rehash会导致服务器一段时间无法提供服务。两个哈希表ht[0]，ht[1]

- rehash期间，收到请求对字典的操作，会顺带将涉及到的键值对rehash到ht[1]中
- rehash期间，字典会对两个哈希表同时进行操作，在0找不到则会到1找。

# 跳跃表

用于有序集合键的底层实现之一。

**由跳跃表节点和跳跃表头组成**，原理其实是增加索引的目的来实现链表的快速查找。平均O(logn)，最坏O(n)的查找

## 跳跃表头

![image-20220212142821115](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212142821115.png)

## 跳跃表节点

![image-20220212142927311](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212142927311.png)

层：这个节点有多少层，每层都有前进指针，即该指针指向下一个节点的跨度

后退指针，只有一个后退指针，指向上一个节点。

分值、成员对象。

# 整数集合

用于保存整数值的抽象数据结构

![image-20220212143143892](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212143143892.png)

contents的元素大小，由encoding决定，如果encoding是intset_enc_int16，则整数集合的底层实现是int16_t。

## 升级

必须保证contents的元素类型一致，即要么都是int16，要么都是int32。如果新增加一个元素是int32到int16的content中，那么整个contents都需要升级。

- 灵活：通过自动升级来适应新元素。
- 节约内存：由int16  int32   int64，如果随意类型，那么只能使用int64来存储，那么必然会导致内存浪费。

## 降级

不会降级

# 压缩列表

列表键和哈希键的底层实现之一。当列表只包含少量列表项，且每个列表项都是小整数值、比较短的字符串。

内存连续的。

![image-20220212144740213](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212144740213.png)

zltail 表尾节点是指entryN，压缩列表的起始地址是zlbytes

## 压缩列表节点

![image-20220212145017723](C:\Users\Administrator\Desktop\redis笔记\images\image-20220212145017723.png)

previous_entry_length ：记录上一个节点的长度。用于当前节点的起始指针 - 该值 = 上一个节点的起始指针。

## 连锁更新

因为previous_entry_length记录上个节点的长度，如果上个节点扩容，将导致当前节点该值扩容。实际并不多见，且只要被更新节点不多，就不会对性能造成影响。

## 例子

```js
lpush list 1 2 3 
object encoding list
```

