# grafana

监控平台（mysql）

# 单点登录

https://blog.csdn.net/qq_33472765/article/details/81489158

登录系统（s1）、第三方系统（s2）。

s2判断session，无则拼接访问s1的地址，并带上回调地址。s1点击登录通过回调地址访问回s2并带上code，code是一个凭证（带上s2的ip和当前时间），s1收到请求，解析code，判断s2的ip和崩瓷请求的ip是否一致，时间是否过期。都正常则s1再调用s2获取登录信息（s1给s2传应用信息，s2返回用户信息）。

s1存放全局会话，s2存放局部会话。

s1 和 s2 的每次交互都要验证对方的ip。

# 大文件上传下载

## 上传

大文件上传的原因：超时、失败后得重新开始。速度并不是重要的影响因素。

- 前端将文件分片：基于blob对象的slice方法，file是继承于blob的，file.splice(0,size);，将所有的片放到arr中。
- 前端使用sparkmd5包，计算文件完整的md5值。
- 前端上传前先调用后端校验的接口，用于验证文件是否上传成功（是否已经存在文件）是则返回。否则查看分片目录下是否存在分片，看看分片上传了多少，所有分片信息返回给前端。
- 如果文件已经存在则就算实现秒传（进度条直接100），如果文件不存在，但是存在分片信息（修改进度条），则验证并将其他未上传的分片上传。前端上传后，通知后端进行文件合并。
- 后端通过fs的append，合并所有分片文件，并计算allmd5。根据前端计算的allmd5和后端的allmd5进行对比。
- todo：后端怎么计算md5。要很久？fork子进程？
- todo：获取合并的进度，怎么判断。

优化的点：也可以计算抽样md5值：使用每个片的前中后三个字节组合成的数据进行md5。因为大文件（G级别）的文件计算md5很慢。（1个g，抽样要800ms，完整的md5要20s）

## 下载

- 原理

https://blog.csdn.net/thanklife/article/details/77962767

https://www.cnblogs.com/zxtceq/p/7146760.html

客户端发送range头部，标明需要文件的范围

```js
    表示头500个字节：Range: bytes=0-499
    表示第二个500字节：Range: bytes=500-999
    表示最后500个字节：Range: bytes=-500
    表示500字节以后的范围：Range: bytes=500-
    第一个和最后一个字节：Range: bytes=0-0,-1
    同时指定几个范围：Range: bytes=500-600,601-999
```

响应content-range，

```js
HTTP/1.1 206 OK
表示处理请求成功，响应报文还有这一行
Content-Range: bytes 200-299/403
斜杠后面的403表示文件的大小，通常Content-Range的用法为：
     . The first 500 bytes:
     Content-Range: bytes 0-499/1234

     . The second 500 bytes:
     Content-Range: bytes 500-999/1234

     . All except for the first 500 bytes:
     Content-Range: bytes 500-1233/1234

     . The last 500 bytes:
     Content-Range: bytes 734-1233/1234
```

- 实现

koa-range 包，将其放到路由上，自动帮我们实现。

注意看issue，koa-range存在问题。

![image-20220209222612016](E:\dailynote\mianshi\images\image-20220209222612016.png)

简单说就是：每次收到请求后，koa-range是读取整个大文件的流，然后再splice截取需要的字节返回给客户端。

解决：使用fs.createReadStream(path,{start,end});

其他包：[@masx200/koa-range ](https://www.npmjs.com/package/@masx200/koa-range) 使用此包即可。

