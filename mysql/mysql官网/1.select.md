https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html

# where

- 创建临时表

```
If there is an ORDER BY clause and a different GROUP BY clause, or if the ORDER BY or GROUP BY contains columns from tables other than the first table in the join queue, a temporary table is created.
```

如果存在ORDER BY子句和其他GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则会创建一个临时表。

# range

# index merge

对一个表使用多个索引，对它们同时扫描，并且合并结果。（通过取交集或者是并集）

缺点：

- 尝试将以下进行转化

```js
(x AND y) OR z => (x OR z) AND (y OR z)
(x OR y) AND z => (x AND z) OR (y AND z)
```

- 不适用全文索引

三种算法：

- using intersect
- using union
- using sort_union （略）

## using intersect （取交集）

适用于where子句用and来拼接不同索引键上的查询条件，并且每个条件都是以下条件之一：

```js
1.key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN (某个索引的所有部分都被覆盖)

2.InnoDB表通过主键的范围查询。
```

例子：

```mysql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE (key1_part1 = 1 AND key1_part2 = 2) AND key2 = 2;
```

使用and 拼接条件。

条件可以是：主键的查询，辅助索引（联合索引）的左匹配查询，辅助索引的查询（单索引）



## using union（取并集）

使用or拼接

```js
1.key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN (某个索引的所有部分都被覆盖)

2.InnoDB表通过主键的范围查询。

3.符合using intersect 比如上述的（ primary_key < 10 AND key_col1 = 20）
```

例子：

```mysql
SELECT * FROM t1
  WHERE key1 = 1 OR key2 = 2 OR key3 = 3;

SELECT * FROM innodb_table
  WHERE (key1 = 1 AND key2 = 2)
     OR (key3 = 'foo' AND key4 = 'bar') AND key5 = 5;
```

解析：   (key1 = 1 AND key2 = 2)   和 (key3 = 'foo' AND key4 = 'bar') AND key5 = 5 都是符合第三点条件。 然后用or拼接

## using sort-union

和 using union的区别是 sort-union 必须为所有行取id，然后在返回任何行之前对其进行排序。

# index condition pushdown

作用：虽然有些查询条件不走索引，但是能够通过索引来实现筛选，也就是在存储引擎层面就进行筛选，而不是回表找到具体数据后再进行筛选。

## 例子

```js
组合索引（age、name） 查询条件（age=10 and name like '%ss%'） 
已知name不可能走索引，但是可以通过组合索引的name 将符合age=10 但不符合 %ss%的筛选掉。

组合索引（age、city、birth）  查询条件 （age=10 and birth ='2010-10-10'）
已知birth不走索引，因为不符合最左匹配，但是通过可以在存储引擎阶段将birth不符合的筛选掉
```

这就是icp的作用。虽然不走索引，但是能使用索引信息筛选掉不符合的数据，减少回表io及mysql服务器层面的筛选。

## 可略

不使用icp：存储引擎遍历索引，每次遍历都是：读取索引元组，在基表定位读取整行，返回给mysql服务器，再对这些行根据where再进行筛选。

使用icp：每次遍历时，使用索引元组评估，没有满足where条件，则继续遍历，减少查询基表，减少返回给mysql服务器的数据量。

## icp受限

- 当需要访问整个表行时，icp用于range，ref，eq_ref和ref_or_null。

- 在innodb中，icp只用于辅助索引（二级索引）。icp的目的在于减少读取行的次数，减少访问基表的次数。而innodb聚集索引，完整的记录已经读入innodb缓冲区。这种情况下使用icp不会减少io。
- 在虚拟生成的列上创建的二级索引不支持ICP。 InnoDB支持虚拟生成列上的二级索引。

- 子查询无法使用。

- 存储访问无法使用。

- 触发器无法使用。

# nested-loop join algorithms 

# nested join

# outer join 

左连接和右连接，可以互相转化为等效。

对于LEFT JOIN，如果对于所生成的NULL行，WHERE条件始终为false，则将LEFT JOIN更改为内部联接。

# multi-range read

正常查询：每次遍历时：在二级索引找到主键id，再通过id找主表。

问题：如果表很大，符合条件的很多，则第一次找到id是1，再1000，再2000，3000等 2 .像这种id间隔很大。如果主表不在内存中，则需要将页读取到内存中。如果满了，还需要将旧页替换掉。如果1所在的页放到内存，再1000和2000所在的页，如果这时候内存满了（buffer pool），则将1所在的页替换掉。这时候如果访问id为2，1和2是在同一页。这时候就多了很多没必要的操作。 

解决：mysql先扫描二级索引并收集所有的主键id，排序，然后再从基表拿，这时候就不会出现1所在的页拿出来，被替换掉，而后续又要拿出来。

在虚拟生成列上创建的二级索引不支持MRR优化。 InnoDB支持虚拟生成列上的二级索引。

以下方案说明了MRR优化何时有利：

场景A：MRR可用于索引范围扫描和等连接操作的表InnoDB和 MyISAM表。

1. 索引元组的一部分累积在缓冲区中。
2. 缓冲区中的元组按其数据行ID排序。
3. 根据排序的索引元组序列访问数据行。

当使用了MRR优化时，EXPLAIN查询执行计划时Extra会显示MRR。

# condition filtering

作用：联表时，减少驱动表的记录，进而减少联表io操作。 具体实现不知。

如果没有使用条件过滤，join查询的驱动表预估扫描的记录数与索引条件相关，比如一个二级索引 idx_name(name)，name=‘abc’ 的记录数有100个，那么执行计划中的预估扫描记录数就是rows = 100，filter：100%。如果此时where条件中关于驱动表有另外一个条件限制，比如age=20，满足name='abc’且age=20的记录数为10，通过条件过滤后，实际参与到join运算的驱动表记录数只有10条左右。即执行计划，rows=100，filter：10%

条件过滤有一些限制：

- 条件只能是常量

- 条件过滤中的where条件不在索引条件中

explain中，rows表示索引访问方式预计扫描的记录数，而filtered字段反映了条件过滤。值越小，说明过滤效果越好。

例子：

```mysql
SELECT *
  FROM employee JOIN department ON employee.dept_no = department.dept_no
  WHERE employee.first_name = 'John'
  AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01';
```

- employee表记录总数：1024
- department表记录总数：12
- 两张表在dept_no字段上都有索引。
- employee表在first_name上有索引。
- 满足 employee.first_name = ‘John’ 的记录数：8
- 满足 employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’ 的记录数：150
- 满足 employee.first_name = ‘John’ AND employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’ 记录数：1

不用条件过滤

```js
+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+

```

使用条件过滤

```js
+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+

```

很明显，表employee上的filtered 由 100 变为了 16.31，8 × 16.31% = 1.3，过滤效果非常好。

MySQL提供了参数来控制是否打开条件过滤，默认是打开的。

SET optimizer_switch = ‘condition_fanout_filter=on’;

打开条件过滤有时并不总是能提高性能，优化器可能会高估条件过滤的影响，个别场景下使用条件过滤反而会导致性能下降。在排查类似性能问题时，可参考以下思路：

join连接的字段是否有索引，如果没有索引，则应当先加上索引，以便优化器能够掌握字段值的分布情况，更准确的预估行数。
表的join顺序是否合适，通过改变表的join顺序，让更小的表作为驱动表。可以考虑使用STRAIGHT_JOIN，强制优化器使用指定的表join顺序。
如果不使用条件过滤，性能会更好，那么可以关闭会话级条件过滤功能。默认是打开的
SET optimizer_switch = ‘condition_fanout_filter=off’;

# is null

# order by 

https://blog.csdn.net/itas109/article/details/79386327

对所有group by c1,c2 查询进行了排序，就像在group by c1 ，c2 查询指定了order by c1，c2。如果希望避免排序的开销，可以通过order by null来禁止。

```mysql
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
```

## 无法使用索引排序

- 排序字段归属两个不同的索引
- 联合索引排序，排序字段不符合最左匹配
- asc和desc混用，mysql 8 好像允许
- where使用到的索引和order使用的索引不一致
- 只对字段的前缀加index，也无法使用索引排序
- 

## filesort

无法使用索引来进行排序时，使用文件排序。

### 优化

如果无法使用索引排序，则尝试以下优化，尽量减少文件排序花费的时间

- sort_buffer_size 应尽可能地大，可以减少写磁盘文件和文件合并的时间。
- max_sort_length
- sort_merge_passes
- read_rnd_buffer_size

### 原始

- 查询出所有符合的行，将排序字段和行id组成元组存进buffer。
- 如果所有行满足buffer则排序并找到对应的行返回。不符合则buffer满了后排序然后存进磁盘文件，然后将所有文件归并排序，并找到对应行返回。

### 改进

- 元组存放排序字段和查询字段。减少二次查询基表的操作。

### 总结

The `sort_mode` value provides information about the contents of tuples in the sort buffer:

- `<sort_key, rowid>`: This indicates that sort buffer tuples are pairs that contain the sort key value and row ID of the original table row. Tuples are sorted by sort key value and the row ID is used to read the row from the table.
- `<sort_key, additional_fields>`: This indicates that sort buffer tuples contain the sort key value and columns referenced by the query. Tuples are sorted by sort key value and column values are read directly from the tuple.
- `<sort_key, packed_additional_fields>`: Like the previous variant, but the additional columns are packed tightly together instead of using a fixed-length encoding.

# group by

一般情况是建立临时表，然后再根据临时表来进行分组和聚合函数的操作。

## 松散索引扫描

使用索引的部分最左前缀即可

- 单表group by
- 索引的最左匹配
- 聚合函数只能max和min，如果两者都使用，则只能引用同一列字段
- 其他的索引字段则只能匹配常量
- 索引字段不能是前缀匹配（字符串a，index(a(10)) ，即a不能只取前10个字符作为索引）

松散索引扫描需要读取的键值数量与分组的组数量一样多。而在WHERE 子句包含范围判断式或者等值表达式的时候， 松散索引扫描查找满足范围条件的每个组的第1 个关键字，并且再次读取尽可能最少数量的关键字。

## 紧凑索引扫描

紧凑索引扫描实现GROUP BY 和松散索引扫描的区别主要在于他需要在扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成GROUP BY 操作得到相应结果。

# distinct 

a `DISTINCT` clause can be considered as a special case of `GROUP BY`

# limit

和order by的问题。

If you combine `LIMIT *`row_count`*` with `ORDER BY`, MySQL stops sorting as soon as it has found the first *`row_count`* rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the `LIMIT` clause are selected, and most or all of them are sorted, before the first *`row_count`* are found. After the initial rows have been found, MySQL does not sort any remainder of the result set

If it is important to ensure the same row order with and without `LIMIT`, include additional columns in the `ORDER BY` clause to make the order deterministic.
