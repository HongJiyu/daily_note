https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html

# where

- 创建临时表

```
If there is an ORDER BY clause and a different GROUP BY clause, or if the ORDER BY or GROUP BY contains columns from tables other than the first table in the join queue, a temporary table is created.
```

如果存在ORDER BY子句和其他GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则会创建一个临时表。



# range

# index merge

对一个表使用多个索引，对它们同时扫描，并且合并结果。对一个表的结果进行合并。而不是搜索两个表，用各自的索引然后进行合并。

index merge 的缺陷

- 尝试将以下进行转化

```js
(x AND y) OR z => (x OR z) AND (y OR z)
(x OR y) AND z => (x AND z) OR (y AND z)
```

- 不适用全文索引
- 如果是范围查询，则优化器不考虑使用index merge

三种算法：

- using intersect
- using union
- using sort_union

## using intersect 

适用于where子句用and结合的不同索引键上的范围查询，并且每个条件都是以下条件之一：

```js
1.key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN (某个索引的所有部分都被覆盖)

2.InnoDB表通过主键的任何范围条件。
```

例子：

```mysql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE (key1_part1 = 1 AND key1_part2 = 2) AND key2 = 2;
```

对所有使用的索引执行同时扫描，并产生从合并索引扫描中接收到的行序列的交集。

## using union

将 and 改为or。

- 同上
- 同上
- 索引合并intersection访问算法使用的条件。（具体看例子2）

例子：

```mysql
SELECT * FROM t1
  WHERE key1 = 1 OR key2 = 2 OR key3 = 3;

SELECT * FROM innodb_table
  WHERE (key1 = 1 AND key2 = 2)
     OR (key3 = 'foo' AND key4 = 'bar') AND key5 = 5;
```

## using sort-union

和 using union的区别是 sort-union 必须为所有行取id，然后在返回任何行之前对其进行排序。

# index condition pushdown

不使用icp：存储引擎遍历索引，每次遍历都是：读取索引元组，在基表定位读取整行，返回给mysql服务器，再对这些行根据where再进行筛选。

使用icp：每次遍历时，使用索引元组评估，没有满足where条件，则继续遍历，减少查询基表，减少返回给mysql服务器的数据量。

icp受限：

- 当需要访问整个表行时，icp用于range，ref，eq_ref和ref_or_null。

- 在innodb中，icp只用于辅助索引（二级索引）。icp的目的在于减少读取行的次数，减少访问基表的次数。而innodb聚集索引，完整的记录已经读入innodb缓冲区。这种情况下使用icp不会减少io。
- 在虚拟生成的列上创建的二级索引不支持ICP。 InnoDB支持虚拟生成列上的二级索引。

- 子查询无法使用。

- 存储访问无法使用。

- 触发器无法使用。

例子：

建立二级索引：`INDEX (zipcode, lastname, firstname)`

```mysql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
```

不使用icp时：只会使用二级索引的部分，即zipcode，然后筛选出所有95054，再进行回表，返回给server，再进行筛选。

使用icp：虽然只使用了zipcode，但是还能根据索引元组，对lastname进行筛选，也就是对建立的二级索引进行充分运用。

# nested-loop join algorithms 

# nested join

# outer join 

左连接和右连接，可以互相转化为等效。

对于LEFT JOIN，如果对于所生成的NULL行，WHERE条件始终为false，则将LEFT JOIN更改为内部联接。

# multi-range read

正常查询：每次遍历时：在二级索引找到主键id，再通过id找主表。

问题：如果表很大，符合条件的很多，则第一次找到id是1，再1000，再2000，3000等 2 .像这种id间隔很大。如果主表不在内存中，则需要将页读取到内存中。如果满了，还需要将旧页替换掉。如果1所在的页放到内存，再1000和2000所在的页，如果这时候内存满了（buffer pool），则将1所在的页替换掉。这时候如果访问id为2，1和2是在同一页。这时候就多了很多没必要的操作。 

解决：mysql先扫描二级索引并收集所有的主键id，排序，然后再从基表拿，这时候就不会出现1所在的页拿出来，被替换掉，而后续又要拿出来。

在虚拟生成列上创建的二级索引不支持MRR优化。 InnoDB支持虚拟生成列上的二级索引。

以下方案说明了MRR优化何时有利：

场景A：MRR可用于索引范围扫描和等连接操作的表InnoDB和 MyISAM表。

1. 索引元组的一部分累积在缓冲区中。
2. 缓冲区中的元组按其数据行ID排序。
3. 根据排序的索引元组序列访问数据行。

当使用了MRR优化时，EXPLAIN查询执行计划时Extra会显示MRR。

# condition filtering

如果没有使用条件过滤，join查询的驱动表预估扫描的记录数与索引条件相关，比如一个二级索引 idx_name(name)，name=‘abc’ 的记录数有100个，那么执行计划中的预估扫描记录数就是rows = 100，filter：100%。如果此时where条件中关于驱动表有另外一个条件限制，比如age=20，满足name='abc’且age=20的记录数为10，通过条件过滤后，实际参与到join运算的驱动表记录数只有10条左右。即执行计划，rows=100，filter：10%

条件过滤有一些限制：

- 条件只能是常量

- 条件过滤中的where条件不在索引条件中

explain中，rows表示索引访问方式预计扫描的记录数，而filtered字段反映了条件过滤。值越小，说明过滤效果越好。

例子：

```mysql
SELECT *
  FROM employee JOIN department ON employee.dept_no = department.dept_no
  WHERE employee.first_name = 'John'
  AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01';
```

- employee表记录总数：1024
- department表记录总数：12
- 两张表在dept_no字段上都有索引。
- employee表在first_name上有索引。
- 满足 employee.first_name = ‘John’ 的记录数：8
- 满足 employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’ 的记录数：150
- 满足 employee.first_name = ‘John’ AND employee.hire_date BETWEEN ‘2018-01-01’ AND ‘2018-06-01’ 记录数：1

不用条件过滤

```js
+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+

```

使用条件过滤

```js
+----+------------+--------+------------------+---------+---------+------+----------+
| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |
+----+------------+--------+------------------+---------+---------+------+----------+
| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |
| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |
+----+------------+--------+------------------+---------+---------+------+----------+

```

很明显，表employee上的filtered 由 100 变为了 16.31，8 × 16.31% = 1.3，过滤效果非常好。

MySQL提供了参数来控制是否打开条件过滤，默认是打开的。

SET optimizer_switch = ‘condition_fanout_filter=on’;

打开条件过滤有时并不总是能提高性能，优化器可能会高估条件过滤的影响，个别场景下使用条件过滤反而会导致性能下降。在排查类似性能问题时，可参考以下思路：

join连接的字段是否有索引，如果没有索引，则应当先加上索引，以便优化器能够掌握字段值的分布情况，更准确的预估行数。
表的join顺序是否合适，通过改变表的join顺序，让更小的表作为驱动表。可以考虑使用STRAIGHT_JOIN，强制优化器使用指定的表join顺序。
如果不使用条件过滤，性能会更好，那么可以关闭会话级条件过滤功能。
SET optimizer_switch = ‘condition_fanout_filter=off’;

# is null

# order by 

https://blog.csdn.net/itas109/article/details/79386327

对所有group by c1,c2 查询进行了排序，就像在group by c1 ，c2 查询指定了order by c1，c2。如果希望避免排序的开销，可以通过order by null来禁止。

```mysql
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
```

