# 自动伸缩原理

通过创建HorizontalpodAutoscaler（HPA）资源来启用和配置Horizontal控制器。该控制器周期性地检查pod度量，计算满足HPA资源所配置的目标数值所需的副本数量。进而调整replicas字段。

三个步骤：

- 后去被伸缩资源对象所管理的所有pod度量
- 计算度量到达指定值所需pod数量
- 更新replicas字段

## 获取pod度量

![image-20201026223326788](E:\0git_note\docker\img\image-20201026223326788.png)

简单说需要使用cAdvisor和Heapster，具体看上一节。

## 计算所需的pod数量

Autoscaler 获取到所管辖的所有pod的度量后，再根据你给定的期望值，会去计算需要多少个pod才能使所有pod的度量达到期望值。

![image-20201026230639974](E:\0git_note\docker\img\image-20201026230639974.png)

可以看到期望所有的pod的cpu使用率是50%，qps是20。而总cpu使用率是200 ，总qps是57 。则满足cpu需要4个，满足qps需要3个，取最大，所以是扩容到4个。

## 更新副本数

Autoscaler控制Scale子资源来修改replicas字段。

![image-20201026230912176](E:\0git_note\docker\img\image-20201026230912176.png)

目前爆露了Scale子资源的资源有：

Deployment、Replicaset、ReplicationController、StatefulSet。

## 总结

![image-20201026231027284](E:\0git_note\docker\img\image-20201026231027284.png)

# 基础CPU自动伸缩

这里的cpu是指：pod实际使用量/request量。因此可以超过100%。因为request是所需的最小。而实际使用量可以大于它，但是小于limit。

因此需要给伸缩的pod设置CPU请求，不管是直接设置还是通过LimitRange对象设置，这样Autoscaler才能确定使用率。

创建Deployment：

![image-20201026231414912](E:\0git_note\docker\img\image-20201026231414912.png)

创建HPA对象：

```shell
kubectl autoscale deployment kubia --cpu-percent=30 --min=1 --max=5
```

创建hpa对象，并把deployment名为kubia的作为伸缩目标。期望所有的pod cpu为30%，pod最小1个，最大5个。

**注意：一定要是Deployment，而不是ReplicaSet，这样才能确保预期的副本数量在应用给更新后继续保持（不懂）**

![image-20201026231729685](E:\0git_note\docker\img\image-20201026231729685.png)

## 观察第一个伸缩事件

```shell
kubectl get hpa
```

一开始，需要等待获取pod度量，所以targets是< unknow>

一开始三个pod无请求，cpu接近0，因此缩小至1个。

查看hpa发生的事件：

```shell
kubectl describe hpa
```

## 自动扩容

先给pod暴露service

```shell
kubectl expost deployment kubia --port=80 --target-port=8070
```

在一个终端执行：

![image-20201026232115796](E:\0git_note\docker\img\image-20201026232115796.png)

这会运行一个pod重复请求kubia服务。

![image-20201026232148727](E:\0git_note\docker\img\image-20201026232148727.png)

再次get hpa和deployment，会发现扩容 了。

### 伸缩速率

单次扩容可增加副本数搜到限制：

副本大于2，单次操作至多翻倍。

副本数只有1、2，最多扩容到4.

时间间隔：

3分钟内没有任何伸缩操作才会触发扩容。

5分钟内没有任何伸缩操作才会触发缩容。

### 修改度量值

kubectl edit