# docker安装

https://docs.docker.com/engine/install/centos/

# 底层技术支持

namespces：做隔离pid,net,ipc,mnt,uts

Control groups：做资源限制

Union file systems：Container和image的分层

# Docker Image 

1. 文件和meta data的集合

2. 分层的，每一层都可以添加改变删除文件，成为一个新的image

3. 不同的image可以共享相同的layer

4. image本身也是read-only的创建一个base image

创建一个image（2中方式，通过bulid dockerfile ，通过pull）

1. 可执行文件
2. 编写Dockerfile
3. docker build -t xx .  //xx表示给这个image命名
4. docker image ls

```js
docker image ls

docker pull ubuntu:14.04  //从docker hub拉取

docker history id  //查看这个image的各层

docker image bulid -t xx  //build an image from dockerfile

docker rmi xx //删除某个image
```

# Docker Container

通过image创建

在image layer之上建立一个container layer

类比面向对象：类和实例

image负责app的存储和分发，container负责允许app

```js
docker container ls -a //列举所有容器，包括当前和允许结束的

docker run -d --name=xx <image> //后台运行，并指定名字

docker run -it <image>  //交互式运行，好像要加/bin/bash

docker container commit //create a new image

docker rm $(docker ps -qa) //删除所有容器
```

# Docker 的Command

查看命令

docker --helper

docker container

docker image

# 创建一个Docker image（两种方法）

在centos的image下，生成一个带有vim功能的centos

1. 通过image ，run一个conotainer，然后yum install vim后，结束后，推出，再通过commit ，生成一个新的image

2. 通过DockerFile去build一个，中间会生成一个临时container。

建议通过dockerfile去生成image

# Dockerfile的语法

https://docs.docker.com/engine/reference/builder/#from 

## FROM

尽量使用官方的image

```js
FROM scrath //制作base image
FROM centos //使用base image
FROM unbuntu:14.04 //
```

## LABEL

声明一些用户信息。类似于注释

```js
LABEL maintainer="hjy@xx.com"
LABEL version="1.0"
```

## RUN

执行shell命令

每run一次，都会在image加一层(image layer)。避免多层，将多条命令组合起来，使用&&和\美观

```js
RUN yum update && yum install -y vim \ python-dev #反斜线换行。
RUN apt-get update && apt-get install -y perl\
pwgen --no-install-recommends && rm -rf \
/var/lib/apt/lists/*                       #注意清理cache
RUN /BIN/BASH -c 'source #HOME/.bashrc;echo $HOME'
```

## WORKDIR

设定工作目录

尽量使用WORKDIR 而不使用RUN cd ，尽量使用绝对路径，更清晰

```js
WORKDIR /root //到根目录的root文件夹下，如果没有则创建
WORKDIR /test 	// 到/root/test文件夹下
RUN pwd 		//输出当前路径/root/test
```

## ADD and COPY

```js
ADD hello /root //拷贝hello到root目录下
ADD hello.tar.gz /root //拷贝hello到root目录下，并且会解压
COPY hello /root //拷贝hello到root目录下
```

COPY由于ADD，因为ADD还有额外的解压功能。

获取远程文件则只能使用RUN curl xx或者RUN wget xxx。

## ENV

设置常量，再后面可以通过${}引用

```js
ENV MYSQL_VERSION 5.6
RUN apt-get install -y mysql-server = "${MYSQL_VERSION}" \ &&
    rm -rf /var/lib/apt/lists/* 
```

## VOLUME and EXPOSE

存储和网络，暂时略

expose 暴露端口

## CMD and ENTRYPOINT

cmd

设置容器启动后默认执行的命令和参数。

如果定义多个CMD,只有最后一个会执行。如果docker run制定了其他命令，CMD命令被忽略。

docker run -it image /bin/bash ,这样，那这个image如果有CMD，也不会被执行。



entrypoint:设置容器启动时运行的命令

让容器以应用程序或服务的形式运行，不会被忽略，一定会执行。



两者结合，执行命令并传参数

dockerfile

```js
FROM ubuntu
RUN apt-get update && apt-get install -y stress
ENTRYPOINT ['/usr/bin/stress']
CMD []
```

docker run -it < image > --vm 1 --xx x --xx x

### shell格式和exec格式

shell格式

```js
RUN apt-get install -y vim
CMD echo "hello docker"
ENTRYPOINT echo "hello docker"
```

exec格式

```js
RUN ["apt-get","install",'-y','vim']
CMD ["/bin/echo","hello docker"]
ENTRYPOINT ["/bin/echo","hello docker"]
```

这种格式不是shell格式，所以无法获取env设置的值，必须再shell下才可以

可以改成：["/bin/bash","-c","echo $name"] ，name是env设置的，这种就是以exec格式，执行shell语句。

# 贡献image

pull image不需要在docker hub上有账号，不过push image 则需要

注意：image命名： docker hub的账号名/xx

docker login

docker image push image命名:tag

上面这种直接上传image不建议。最后是docker hub和git hub关联，然后在git hub维护dockerfile，docker hub会帮我们build

搭建一个私有的registry 

# Dockerfile实战

1.编写dockerfile，把要运行的文件通过copy，拷贝到container里去。通过expose暴露端口

2.docker build ，会列出每步的img，如果出错，可以通过docker run img 到系统去查看。

3.docker run

# 操作container

进入到后台运行的container中：

docker exec -it  < containerId >  /bin/bash

停掉container：docker stop < containerId >  

启动：docker start < containerId >

# 容器资源限制

docker run --help

--memory bytes 200M

--memory-swap bytes 200M

内存大小是以上两个之和

--cpu-shares 10 权重，占比，而不是占用多少个cpu，