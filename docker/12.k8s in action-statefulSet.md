一个数据库的pod，运行多个，每一个都需要单独的持久卷。这种场景是之前的资源对象都无法做到的。

解决：

1. 直接创建pod，而不是用ReplicaSet管理它。
2. 创建多个ReplicaSet，每个ReplicaSet管理一个pod。

集群应用要求每一个实例在集群生命周期内唯一标识。但是pod被新的pod删除，它是全新的主机名和ip。新启动的实例有新的网络标识，同时还用旧实例数据会引起问题。这个需求是：每个集群成员的配置文件种都列出其他集群成员和他们的ip。但是新pod，是会变化的。

解决：每一个pod都对应一个service管理。

综上：

![image-20201020223756852](E:\0git_note\docker\img\image-20201020223756852.png)

# Statefulset

它和ReplicaSet和ReplicationController类似，但又有不一样。

它保证了pod在重新调度后保留他们的标识和状态。同时每个pod可以拥有一组独立的持久卷。pod的命名时有规律固定的。

## 稳定的网络标识

![image-20201020231359803](E:\0git_note\docker\img\image-20201020231359803.png)

1.扩缩容时，扩容在之前的索引号+1，缩容，先缩索引值高的。

2.缩容只会操作一个pod实例，缩容不会很迅速，在有实例不健康的情况下，不允许缩容。

![image-20201020232515518](E:\0git_note\docker\img\image-20201020232515518.png)

![image-20201020232544339](E:\0git_note\docker\img\image-20201020232544339.png)

## 专属存储

持久卷声明和持久卷时一对一的。

持久卷声明被删除，那么持久卷也会被删除。因此statefulset缩容不会去删除持久卷声明。

statefulset每个pod都关联到不同的持久卷声明。

扩容时：创建两个或更多的api对象（pod和持久卷声明）

缩容：只会删除pod

![image-20201020232839801](E:\0git_note\docker\img\image-20201020232839801.png)

## 保障

![image-20201020232941788](E:\0git_note\docker\img\image-20201020232941788.png)

## 使用